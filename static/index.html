<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-time Location Tracker</title>
    <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
    <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; overflow-x: hidden; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header { text-align: center; color: white; margin-bottom: 20px; }
        .header h1 { font-size: 2.5rem; margin-bottom: 10px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
        .header p { font-size: 1.1rem; opacity: 0.9; }

        .dashboard {
            position: relative;
            height: calc(100vh - 160px);
            min-height: 400px;
        }

        .map-container {
            background: white;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
        }

        #map {
            height: 100%;
            width: 100%;
            min-height: 240px;
            display: block;
        }

        .map-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            z-index: 1000;
        }

        .map-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .track-btn, .history-btn, .menu-toggle-btn {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            color: white;
            border: none;
            padding: 12px 16px;
            border-radius: 10px;
            font-weight: 500;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        .history-btn {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
        }

        .menu-toggle-btn {
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
        }

        .track-btn:hover, .history-btn:hover, .menu-toggle-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(34, 197, 94, 0.4);
        }

        .history-btn:hover {
            box-shadow: 0 8px 20px rgba(59, 130, 246, 0.4);
        }
        
        .time-filter-indicator {
            position: absolute;
            top: 60px;
            left: 20px;
            background: rgba(59, 130, 246, 0.95);
            backdrop-filter: blur(10px);
            color: white;
            padding: 8px 12px;
            border-radius: 10px;
            font-size: 12px;
            z-index: 1000;
            display: none;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            margin-top: 10px;
        }

        .time-filter-indicator.show {
            display: block;
        }

        .time-filter-indicator.time-filter-active {
            background: rgba(59, 130, 246, 0.95);
        }

        .time-filter-indicator.location-filter-active {
            background: rgba(16, 185, 129, 0.95); /* Green for location filter */
        }

        .no-filter-overlay {
            position: fixed;  /* Changed from absolute to fixed */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(10px);
            padding: 40px 60px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            z-index: 10500;  /* Increased z-index to be above everything */
            display: none;
            text-align: center;
            border: 3px solid #f59e0b;
            max-width: 90%;
        }

        .no-filter-overlay.show {
            display: block;
            animation: pulseScale 0.5s ease-out;
        }

        .no-filter-overlay h3 {
            margin: 0 0 15px 0;
            color: #f59e0b;
            font-size: 1.8rem;
            font-weight: 700;
        }

        .no-filter-overlay p {
            margin: 0 0 25px 0;
            color: #6b7280;
            font-size: 1.1rem;
            line-height: 1.6;
        }

        .no-filter-overlay .btn {
            margin: 5px;
            padding: 15px 30px;
            font-size: 1rem;
        }

        @keyframes pulseScale {
            0% {
                transform: translate(-50%, -50%) scale(0.9);
                opacity: 0;
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        .mode-indicator {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(10px);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
            z-index: 1000;
            box-shadow: 0 5px 20px rgba(0,0,0,0.15);
            border: 2px solid;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
        }

        .mode-indicator.live-mode {
            border-color: #ef4444;
            color: #dc2626;
        }

        .mode-indicator.history-mode {
            border-color: #3b82f6;
            color: #2563eb;
        }

        .mode-indicator-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .mode-indicator.live-mode .mode-indicator-dot {
            background: #ef4444;
        }

        .mode-indicator.history-mode .mode-indicator-dot {
            background: #3b82f6;
        }

        .route-legend {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(10px);
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 500;
            z-index: 1000;
            box-shadow: 0 5px 20px rgba(0,0,0,0.15);
            border: 2px solid #e5e7eb;
        }
        .menu-toggle-btn:hover {
            box-shadow: 0 8px 20px rgba(139, 92, 246, 0.4);
        }

        .track-btn.disabled {
            background: linear-gradient(135deg, #6b7280, #4b5563);
        }

        .track-btn.disabled:hover {
            box-shadow: 0 8px 20px rgba(107, 114, 128, 0.4);
        }

        .track-icon {
            width: 16px;
            height: 16px;
            border: 2px solid currentColor;
            border-radius: 50%;
            position: relative;
        }

        .track-icon::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 6px;
            height: 6px;
            background: currentColor;
            border-radius: 50%;
        }

        .track-btn.enabled .track-icon {
            animation: pulse-track 2s infinite;
        }

        @keyframes pulse-track {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.1); }
        }

        /* Popup Menu Styles */
        .popup-menu {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            z-index: 10000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .popup-menu.active {
            display: flex;
        }

        .popup-content {
            background: white;
            border-radius: 20px;
            max-width: 90vw;
            max-height: 90vh;
            width: 100%;
            overflow-y: auto;
            box-shadow: 0 25px 50px rgba(0,0,0,0.3);
            animation: popupSlideIn 0.3s ease-out;
        }

        @keyframes popupSlideIn {
            from {
                opacity: 0;
                transform: scale(0.9) translateY(20px);
            }
            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        .popup-header {
            padding: 25px 30px 20px;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border-radius: 20px 20px 0 0;
        }

        .popup-header h2 {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .popup-close {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: all 0.3s ease;
        }

        .popup-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: rotate(90deg);
        }

        .popup-body {
            padding: 0;
            max-height: calc(90vh - 100px);
            overflow-y: auto;
            min-height: 200px !important;
        }
        .menu-tabs {
            display: flex;
            background: #f8fafc;
            border-bottom: 1px solid #e5e7eb;
        }

        .tab-button {
            flex: 1;
            padding: 15px 20px;
            border: none;
            background: transparent;
            cursor: pointer;
            font-weight: 500;
            color: #6b7280;
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
        }

        .tab-button.active {
            color: #667eea;
            border-bottom-color: #667eea;
            background: white;
        }

        .tab-button:hover {
            background: #f1f5f9;
            color: #374151;
        }

        .tab-content {
            display: none;
            padding: 30px;
        }

        .tab-content.active {
            display: block;
        }

        .status {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .connected .status-dot { background: #22c55e; }
        .disconnected .status-dot { background: #ef4444; }
        .reconnecting .status-dot { background: #f59e0b; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .card {
            background: rgba(255,255,255,0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .card h3 { 
            color: white; 
            margin: 0;
            padding: 20px 25px; 
            font-size: 1.2rem; 
            display: flex; 
            align-items: center; 
            gap: 10px; 
            background: linear-gradient(135deg, #667eea, #764ba2);
        }
        
        .card-icon { 
            width: 24px; 
            height: 24px; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-size: 16px;
        }

        .card-body {
            padding: 25px;
        }

        /* Historical Controls */
        .historical-controls {
            background: rgba(249, 250, 251, 0.8);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .historical-controls.active {
            border-color: #3b82f6;
            background: rgba(239, 246, 255, 0.9);
        }
        #history-config-popup .popup-body {
            display: block !important;
            min-height: 300px !important;
        }
        .time-range-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .quick-ranges {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }

        .quick-range-btn {
            background: #f3f4f6;
            border: 1px solid #d1d5db;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .quick-range-btn:hover {
            background: #e5e7eb;
        }

        .quick-range-btn.active {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }

        /* Location List */
        .location-list {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            background: white;
        }

        .location-item { 
            padding: 15px; 
            border-bottom: 1px solid #f3f4f6; 
            background: white; 
            transition: all 0.3s ease; 
            cursor: pointer; 
        }
        
        .location-item:hover { 
            background: #f8fafc;
        }
        
        .location-item:last-child {
            border-bottom: none;
        }
        
        .location-item.latest { 
            background: linear-gradient(135deg, #ecfdf5, #d1fae5); 
        }
        
        .location-item.selected { 
            background: linear-gradient(135deg, #eff6ff, #dbeafe); 
        }

        .device-id { font-weight: 600; color: #374151; margin-bottom: 8px; }
        .coordinates { font-family: 'Courier New', monospace; color: #6b7280; font-size: 0.9rem; margin-bottom: 5px; }
        .timestamp { font-size: 0.8rem; color: #9ca3af; }

        .control-group { margin-bottom: 15px; }
        .control-group label { display: block; margin-bottom: 5px; font-weight: 500; color: #374151; }
        .control-group input, .control-group select { 
            width: 100%; 
            padding: 10px; 
            border: 1px solid #d1d5db; 
            border-radius: 8px; 
            font-size: 14px; 
            background: white; 
        }
        .control-group input:focus, .control-group select:focus { 
            outline: none; 
            border-color: #667eea; 
            box-shadow: 0 0 0 3px rgba(102,126,234,0.1); 
        }
        .control-item {
          display: flex;
          align-items: center;
          justify-content: space-between;
          padding: 6px 10px;
          border-radius: 6px;
          font-size: 14px;
          color: #374151; /* gray-700 */
          background: #f9fafb; /* gray-50 */
          margin-bottom: 6px;
          cursor: pointer;
          transition: background 0.2s, color 0.2s;
        }

        .control-item:hover {
          background: #f3f4f6; /* gray-100 */
        }

        .control-item input[type="checkbox"] {
          accent-color: #3b82f6; /* blue-500 */
          width: 16px;
          height: 16px;
          cursor: pointer;
        }

        .btn { 
            background: linear-gradient(135deg, #667eea, #764ba2); 
            color: white; 
            border: none; 
            padding: 12px 20px; 
            border-radius: 8px; 
            font-weight: 500; 
            width: 100%; 
            cursor: pointer; 
            transition: all 0.3s ease;
            margin-bottom: 10px;
        }
        .btn:hover { 
            transform: translateY(-2px); 
            box-shadow: 0 5px 15px rgba(102,126,234,0.4); 
        }

        .btn.secondary {
            background: linear-gradient(135deg, #6b7280, #4b5563);
        }

        .btn.secondary:hover {
            box-shadow: 0 5px 15px rgba(107, 114, 128, 0.4);
        }

        .stat-item { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            padding: 12px 0; 
            border-bottom: 1px solid #e5e7eb; 
        }
        .stat-item:last-child { border-bottom: none; }
        .stat-label { color: #6b7280; font-size: 0.9rem; }
        .stat-value { font-weight: 600; color: #374151; }

        .loading { 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            padding: 40px; 
            color: #6b7280; 
        }
        
        .spinner { 
            width: 20px; 
            height: 20px; 
            border: 2px solid #e5e7eb; 
            border-top: 2px solid #667eea; 
            border-radius: 50%; 
            animation: spin 1s linear infinite; 
            margin-right: 10px; 
        }
        
        @keyframes spin { 
            0% { transform: rotate(0deg); } 
            100% { transform: rotate(360deg); } 
        }

        .error { 
            color: #ef4444; 
            background: #fef2f2; 
            padding: 10px; 
            border-radius: 8px; 
            border: 1px solid #fecaca; 
            margin-bottom: 15px; 
        }

        /* Desktop specific styles */
        @media (min-width: 1025px) {
            .popup-content {
                max-width: 800px;
                width: 800px;
            }
        }

        /* Tablet styles */
        @media (max-width: 1024px) and (min-width: 769px) {
            .popup-content {
                max-width: 700px;
            }
            
            .time-range-controls {
                grid-template-columns: 1fr;
            }
        }

        /* Mobile styles */
        @media (max-width: 768px) {
            .container { padding: 10px; }
            .header h1 { font-size: 2rem; }
            .dashboard { height: calc(100vh - 120px); }
            .map-controls { right: 10px; top: 10px; }
            .map-overlay { left: 10px; top: 10px; }
            
            .popup-content {
                margin: 10px;
                max-width: calc(100vw - 20px);
                max-height: calc(100vh - 20px);
            }
            
            .popup-header {
                padding: 20px;
            }
            
            .popup-header h2 {
                font-size: 1.3rem;
            }
            
            .tab-content {
                padding: 20px;
            }
            
            .menu-tabs {
                flex-direction: column;
            }
            
            .tab-button {
                text-align: left;
                padding: 12px 20px;
            }
            
            .time-range-controls {
                grid-template-columns: 1fr;
            }
        }

        /* Landscape mobile */
        @media (max-height: 500px) and (orientation: landscape) {
            .dashboard { height: calc(100vh - 80px); }
            .header { margin-bottom: 10px; }
            .header h1 { font-size: 1.8rem; }
            .container { padding: 5px; }
            
            .popup-content {
                max-height: calc(100vh - 10px);
            }
        }

        .pulse-marker {
            width: 20px;
            height: 20px;
            background: #ef4444; /* red */
            border-radius: 50%;
            position: relative;
            z-index: 9999;   /* always above */
        }

        .pulse-marker::after {
            content: "";
            width: 20px;
            height: 20px;
            background: #ef4444;
            border-radius: 50%;
            position: absolute;
            top: 0;
            left: 0;
            animation: pulse 2s infinite;
            opacity: 0.6;
            z-index: -1;  /* glow behind */
        }   
        
        @keyframes pulse {
          0%   { transform: scale(1);   opacity: 0.6; }
          50%  { transform: scale(2);   opacity: 0; }
          100% { transform: scale(1);   opacity: 0.6; }
        }

        .trace-marker {
          width: 10px;
          height: 10px;
          border-radius: 50%;
          background: #3b82f6; /* blue */
          border: 2px solid white;
          box-shadow: 0 0 4px rgba(0,0,0,0.3);
          cursor: pointer;
          opacity: 0;               /* hidden by default */
          transition: opacity 0.2s;
        }

        .trace-marker:hover {
          opacity: 1;               /* show when hovered */
        }

        .trace-marker.always-visible {
          opacity: 1 !important;    /* forced visible */
        }

        .trace-marker.start-point {
          background: #10b981; /* green for start */
          width: 14px;
          height: 14px;
          border: 3px solid white;
          box-shadow: 0 0 6px rgba(16, 185, 129, 0.6);
          opacity: 1 !important;
          z-index: 1001;
        }

        .trace-marker.end-point {
          background: #ef4444; /* red for end */
          width: 14px;
          height: 14px;
          border: 3px solid white;
          box-shadow: 0 0 6px rgba(239, 68, 68, 0.6);
          opacity: 1 !important;
          z-index: 1001;
        }

        .direction-arrow {
            position: absolute;
            width: 3px;
            height: 16px;
            background: #3b82f6;
            opacity: 0.8;
            pointer-events: none;
            z-index: 999;
            transition: opacity 0.2s;
        }

        .direction-arrow::before {
            content: '';
            position: absolute;
            top: -6px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-bottom: 8px solid #3b82f6;
        }

        .direction-arrow.hidden {
            opacity: 0;
        }

        .direction-arrow.always-visible {
            opacity: 0.8 !important;
        }

        .filter-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
            z-index: 10001;
            display: none;
            max-width: 300px;
        }

        .filter-popup.show {
            display: block;
        }

        .btn:disabled {
            background: linear-gradient(135deg, #9ca3af, #6b7280) !important;
            cursor: not-allowed !important;
            transform: none !important;
            box-shadow: none !important;
            opacity: 0.6 !important;
        }

        .btn:disabled:hover {
            transform: none !important;
            box-shadow: none !important;
            background: linear-gradient(135deg, #9ca3af, #6b7280) !important;
        }

        .validation-error {
            color: #ef4444;
            font-size: 12px;
            margin-top: 5px;
            display: none;
        }

        .validation-error.show {
            display: block;
        }
    </style>
</head>
<body>
<div class="container">
    <div class="header">
        <h1>🌍 Real-time Location Tracker</h1>
        <p>Monitoring device locations with live updates and historical view</p>
        <div style="margin-top: 15px;">
            <select id="language-selector" style="padding: 8px 12px; border-radius: 8px; border: 2px solid rgba(255,255,255,0.3); background: rgba(255,255,255,0.2); color: white; font-weight: 500; cursor: pointer;">
                <option value="en">English</option>
                <option value="es">Español</option>
            </select>
        </div>
    </div>

    <div class="dashboard">
        <div class="map-container">
            <div class="map-overlay">
                <div id="connection-status" class="status disconnected">
                    <div class="status-dot"></div>
                    <span>Connecting...</span>
                </div>
            </div>
            <div class="time-filter-indicator" id="time-filter-indicator">
                <div id="time-filter-text">-</div>
            </div>
            <div class="map-controls">
                <button id="track-latest-btn" class="track-btn enabled">
                    <div class="track-icon"></div>
                    <span>Track Latest</span>
                </button>
                <button id="history-mode-btn" class="history-btn">
                    <span>📅</span>
                    <span>History Mode</span>
                </button>
                <button id="history-config-btn" class="history-btn" style="display: none;">
                    <span>📅</span>
                    <span>History Settings</span>
                </button>
                <button id="live-mode-btn" class="history-btn" style="display: none; background: linear-gradient(135deg, #dc2626, #b91c1c);">
                    <span>📍</span>
                    <span>Live Mode</span>
                </button>
                <button id="menu-toggle-btn" class="menu-toggle-btn">
                    <span>⚙️</span>
                    <span>Menu</span>
                </button>
            </div>
            <div id="map"></div>
            <div class="no-filter-overlay" id="no-filter-overlay">
                <h3 id="no-filter-title">⚠️ No Time Filter Applied</h3>
                <p id="no-filter-message">Please configure a time filter in History Settings to view historical data.</p>
                <button class="btn" onclick="locationTracker.openHistoryConfigPopup()">
                    <span id="no-filter-btn-text">Open History Settings</span>
                </button>
                <button class="btn secondary" onclick="locationTracker.hideNoFilterOverlay()">
                    <span id="no-filter-dismiss-text">Dismiss</span>
                </button>
            </div>
            <div class="mode-indicator live-mode" id="mode-indicator">
                <div class="mode-indicator-dot"></div>
                <span>🔴 LIVE MODE</span>
            </div>
            <div class="route-legend" id="route-legend" style="display: none;">
                <div style="display: flex; align-items: center; gap: 8px;">
                    <div style="width: 12px; height: 12px; background: #10b981; border-radius: 50%; border: 2px solid white;"></div>
                    <span style="font-size: 11px;" id="legend-start">Start</span>
                    <div style="flex: 1; height: 4px; background: linear-gradient(to right, #10b981, #f59e0b, #ef4444); margin: 0 5px;"></div>
                    <span style="font-size: 11px;" id="legend-end">End</span>
                    <div style="width: 12px; height: 12px; background: #ef4444; border-radius: 50%; border: 2px solid white;"></div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Main Menu Popup -->
<div class="popup-menu" id="popup-menu">
    <div class="popup-content">
        <div class="popup-header">
            <h2>Controls & Information</h2>
            <button class="popup-close" id="popup-close">×</button>
        </div>
        <div class="popup-body">
            <div class="menu-tabs">
                <button class="tab-button active" data-tab="controls">⚙️ Controls</button>
                <button class="tab-button" data-tab="locations">📍 Locations</button>
            </div>
            
            <!-- Controls Tab -->
            <div class="tab-content active" id="controls-tab">
                <div class="card">
                    <div class="card-body">
                        <div class="control-group">
                            <label for="device-filter">Filter by Device:</label>
                            <select id="device-filter"><option value="">All Devices</option></select>
                        </div>
                        <div class="control-group">
                            <label for="history-limit">History Limit:</label>
                            <input type="number" id="history-limit" value="50" min="10" max="500">
                        </div>
                        <button class="btn" id="refresh-data-btn" onclick="locationTracker.refreshData()">Refresh Data</button>
                    </div>
                    <div class="control-item">
                      <label style="display:flex; align-items:center; gap:6px; cursor:pointer; width:100%;">
                        <input type="checkbox" id="toggle-trace-dots" checked>
                        <span id="trace-dots-label">Show trace dots</span>
                      </label>
                    </div>
                </div>
            </div>
            
            <!-- Locations Tab -->
            <div class="tab-content" id="locations-tab">
                <div class="card">
                    <div class="card-body">
                        <div class="location-list" id="location-list">
                            <div class="loading"><div class="spinner"></div>Loading locations...</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Statistics Tab - Hidden but kept for stats polling -->
            <div class="tab-content" id="stats-tab" style="display: none !important;">
                <div class="card">
                    <div class="card-body stats">
                        <div class="stat-item">
                            <span class="stat-label">Connected Clients:</span>
                            <span class="stat-value" id="connected-clients">-</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Total Locations:</span>
                            <span class="stat-value" id="total-locations">-</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Active Devices:</span>
                            <span class="stat-value" id="active-devices">-</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Last Update:</span>
                            <span class="stat-value" id="last-update">-</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- History Configuration Popup -->
<div class="popup-menu" id="history-config-popup">
    <div class="popup-content">
        <div class="popup-header">
            <h2>📅 Historical View Configuration</h2>
            <button class="popup-close" id="history-config-close">×</button>
        </div>
        <div class="popup-body">
            <div class="menu-tabs">
                <button class="tab-button active" data-tab="time-filter" id="time-filter-tab-btn">⏱️ <span id="time-filter-tab-label">Time Filter</span></button>
                <button class="tab-button" data-tab="location-filter" id="location-filter-tab-btn">📍 <span id="location-filter-tab-label">Location Filter</span></button>
            </div>

            <!-- Time Filter Tab -->
            <div class="tab-content active" id="time-filter-tab">
                <div class="card">
                    <div class="card-body">
                        <div class="historical-controls active" id="historical-controls-popup">
                            <div class="quick-ranges">
                                <button class="quick-range-btn" data-hours="1">1h</button>
                                <button class="quick-range-btn" data-hours="6">6h</button>
                                <button class="quick-range-btn" data-hours="24">24h</button>
                                <button class="quick-range-btn" data-hours="168">1w</button>
                                <button class="quick-range-btn" data-hours="0">All</button>
                            </div>
                            <div class="time-range-controls">
                                <div class="control-group">
                                    <label for="start-time-popup">From:</label>
                                    <input type="datetime-local" id="start-time-popup">
                                </div>
                                <div class="control-group">
                                    <label for="end-time-popup">To:</label>
                                    <input type="datetime-local" id="end-time-popup">
                                </div>
                            </div>
                            <div class="validation-error" id="validation-error"></div>
                            <button class="btn" id="apply-time-filter-popup">Apply Time Filter</button>
                            <button class="btn secondary" id="clear-time-filter-popup">Clear Filter</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Location Filter Tab -->
            <div class="tab-content" id="location-filter-tab">
                <div class="card">
                    <div class="card-body">
                        <div class="control-group">
                            <label for="location-lat-input" id="location-lat-label">Latitude:</label>
                            <input type="number" id="location-lat-input" step="0.000001" placeholder="e.g., 40.7128">
                        </div>
                        <div class="control-group">
                            <label for="location-lng-input" id="location-lng-label">Longitude:</label>
                            <input type="number" id="location-lng-input" step="0.000001" placeholder="e.g., -74.0060">
                        </div>
                        <div class="control-group">
                            <label for="location-radius-input" id="location-radius-label">Radius (km):</label>
                            <input type="number" id="location-radius-input" value="0.5" min="0.1" max="50" step="0.1">
                        </div>
                        <div class="validation-error" id="location-validation-error"></div>
                        <button class="btn" id="apply-location-filter">Apply Location Filter</button>
                        <button class="btn secondary" id="clear-location-filter">Clear Filter</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Empty Results Popup -->
<div class="filter-popup" id="empty-results-popup">
    <h3 style="margin: 0 0 10px 0; color: #374151;">No Results Found</h3>
    <p style="margin: 0 0 15px 0; color: #6b7280;">The selected time range contains no location data.</p>
    <button class="btn" onclick="locationTracker.closeEmptyResultsPopup()">OK</button>
</div>

<script>
class LocationTracker {
    constructor() {
        this.ws = null;
        this.map = null;
        this.markers = new Map();
        this.locations = [];
        this.filteredLocations = [];
        this.devices = new Set();
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 10;
        this.selectedDevice = '';
        this.historyLimit = 50;
        this.isTrackingLatest = true;
        this.selectedLocationIndex = -1;
        this.userInteracted = false;
        this.routeCoords = [];
        this.isHistoryMode = false;
        this.timeFilter = null;
        this.suppressUserInteraction = false;
        this.traceMarkers = [];
        this.showTraceDots = true;
        this.liveUpdateQueue = []; 
        this.persistedTimeFilter = null;
        this.selectedLocationMarker = null;
        this.liveUpdateQueue = []; 
        this.persistedTimeFilter = null;
        this.selectedLocationMarker = null;
        this.liveLocations = []; 
        this.initialDbLocation = null; 
        this.hasReceivedLiveUpdate = false;
        this.locationFilter = null; // Add this line
        this.activeFilterType = null; // Add this line: 'time', 'location', or null
        this.translations = {
            en: {
                title: "🌍 Real-time Location Tracker",
                subtitle: "Monitoring device locations with live updates and historical view",
                connecting: "Connecting...",
                connected: "Connected",
                disconnected: "Disconnected",
                connectionError: "Connection Error",
                reconnecting: "Reconnecting in {0}s... ({1}/{2})",
                connectionFailed: "Connection failed - refresh page",
                trackLatest: "Track Latest",
                trackingOff: "Tracking Off",
                historyMode: "History Mode",
                historySettings: "History Settings",
                liveMode: "Live Mode",
                menu: "Menu",
                liveModeBadge: "🔴 LIVE MODE",
                historyModeBadge: "📅 HISTORY MODE",
                legendStart: "Start (oldest)",
                legendEnd: "End (newest)",
                filterLabel: "Filter:",
                to: "to",
                noTimeFilterApplied: "No time filter applied",
                configureInHistorySettings: "Configure in History Settings",
                controlsAndInfo: "Controls & Information",
                controls: "⚙️ Controls",
                locations: "📍 Locations",
                filterByDevice: "Filter by Device:",
                allDevices: "All Devices",
                historyLimit: "History Limit:",
                refreshData: "Refresh Data",
                refreshDataHistorical: "Refresh Data (Historical Mode)",
                showTraceDots: "Show trace dots",
                loadingLocations: "Loading locations...",
                noLocationsFound: "No locations found",
                historicalViewConfig: "📅 Historical View Configuration",
                quickRanges: ["1h", "6h", "24h", "1w", "All"],
                from: "From:",
                to: "To:",
                applyTimeFilter: "Apply Time Filter",
                clearFilter: "Clear Filter",
                noResultsTitle: "No Results Found",
                noResultsMessage: "The selected time range contains no location data.",
                ok: "OK",
                deviceId: "Device ID",
                coordinates: "Coordinates",
                time: "Time",
                start: "START",
                end: "END",
                selected: "SELECTED",
                clearSelection: "Clear Selection",
                noTimeFilter: "No time filter applied",
                configureInSettings: "Configure in History Settings",
                filterLabel: "Filter:",
                timeFilterTabLabel: "Time Filter",
                locationFilterTabLabel: "Location Filter",
                latitude: "Latitude",
                longitude: "Longitude",
                radiusKm: "Radius (km)",
                applyLocationFilter: "Apply Location Filter",
                validLocationRequired: "Valid latitude and longitude are required",
                invalidCoordinates: "Invalid coordinates (lat: -90 to 90, lng: -180 to 180)",
                invalidRadius: "Radius must be greater than 0",
                noFilterTitle: "⚠️ No Time Filter Applied",
                noFilterMessage: "Please configure a time filter in History Settings to view historical data.",
                openHistorySettings: "Open History Settings",
                dismiss: "Dismiss",
                validationErrors: {
                    required: "Both start and end times are required",
                    invalidFormat: "Invalid date format",
                    startAfterEnd: "Start time must be before end time",
                    futureEnd: "End time cannot be in the future",
                    rangeTooLarge: "Time range cannot exceed 1 year",
                    rangeTooSmall: "Time range must be at least 1 minute",
                    tooFarBack: "Start time cannot be more than 10 years ago"
                }
            },
            es: {
                title: "🌍 Rastreador de Ubicación en Tiempo Real",
                subtitle: "Monitoreando ubicaciones de dispositivos con actualizaciones en vivo y vista histórica",
                connecting: "Conectando...",
                connected: "Conectado",
                disconnected: "Desconectado",
                connectionError: "Error de Conexión",
                reconnecting: "Reconectando en {0}s... ({1}/{2})",
                connectionFailed: "Conexión fallida - actualice la página",
                trackLatest: "Seguir Último",
                trackingOff: "Seguimiento Desactivado",
                historyMode: "Modo Histórico",
                historySettings: "Configuración Histórica",
                liveMode: "Modo en Vivo",
                menu: "Menú",
                liveModeBadge: "🔴 MODO EN VIVO",
                historyModeBadge: "📅 MODO HISTÓRICO",
                legendStart: "Inicio (más antiguo)",
                legendEnd: "Fin (más reciente)",
                filterLabel: "Filtro:",
                to: "hasta",
                noTimeFilterApplied: "No se aplicó filtro de tiempo",
                configureInHistorySettings: "Configurar en Ajustes de Historial",
                controlsAndInfo: "Controles e Información",
                controls: "⚙️ Controles",
                locations: "📍 Ubicaciones",
                filterByDevice: "Filtrar por Dispositivo:",
                allDevices: "Todos los Dispositivos",
                historyLimit: "Límite de Historial:",
                refreshData: "Actualizar Datos",
                refreshDataHistorical: "Actualizar Datos (Modo Histórico)",
                showTraceDots: "Mostrar puntos de ruta",
                loadingLocations: "Cargando ubicaciones...",
                noLocationsFound: "No se encontraron ubicaciones",
                historicalViewConfig: "📅 Configuración de Vista Histórica",
                quickRanges: ["1h", "6h", "24h", "1sem", "Todo"],
                from: "Desde:",
                to: "Hasta:",
                applyTimeFilter: "Aplicar Filtro de Tiempo",
                clearFilter: "Limpiar Filtro",
                noResultsTitle: "No se Encontraron Resultados",
                noResultsMessage: "El rango de tiempo seleccionado no contiene datos de ubicación.",
                ok: "Aceptar",
                deviceId: "ID de Dispositivo",
                coordinates: "Coordenadas",
                time: "Hora",
                start: "INICIO",
                end: "FIN",
                selected: "SELECCIONADO",
                clearSelection: "Limpiar Selección",
                noTimeFilter: "No se aplicó filtro de tiempo",
                configureInSettings: "Configurar en Ajustes de Historial",
                filterLabel: "Filtro:",
                timeFilterTabLabel: "Filtro de Tiempo",
                locationFilterTabLabel: "Filtro de Ubicación",
                latitude: "Latitud",
                longitude: "Longitud",
                radiusKm: "Radio (km)",
                applyLocationFilter: "Aplicar Filtro de Ubicación",
                validLocationRequired: "Se requiere latitud y longitud válidas",
                invalidCoordinates: "Coordenadas inválidas (lat: -90 a 90, lng: -180 a 180)",
                invalidRadius: "El radio debe ser mayor que 0",
                noFilterTitle: "⚠️ No se Aplicó Filtro de Tiempo",
                noFilterMessage: "Por favor configure un filtro de tiempo en Ajustes de Historial para ver datos históricos.",
                openHistorySettings: "Abrir Ajustes de Historial",
                dismiss: "Cerrar",
                validationErrors: {
                    required: "Se requieren hora de inicio y fin",
                    invalidFormat: "Formato de fecha inválido",
                    startAfterEnd: "La hora de inicio debe ser anterior a la hora de fin",
                    futureEnd: "La hora de fin no puede estar en el futuro",
                    rangeTooLarge: "El rango de tiempo no puede exceder 1 año",
                    rangeTooSmall: "El rango de tiempo debe ser de al menos 1 minuto",
                    tooFarBack: "La hora de inicio no puede ser hace más de 10 años"
                }
            }
        };
        this.currentLanguage = this.detectLanguage();

        this.config = {
            apiBaseUrl: window.location.origin + ('${BASE_PATH}' || ''),
            wsUrl: `${window.location.protocol === 'https:' ? 'wss:' : 'ws:'}//${window.location.host}${'${BASE_PATH}' || ''}/ws`,
            mapStyle: 'https://basemaps.cartocdn.com/gl/voyager-gl-style/style.json',
            defaultCenter: [-74.0060, 40.7128],
            defaultZoom: 10
        };

        this.initializeApp();
    }

    detectLanguage() {
        const browserLang = navigator.language || navigator.userLanguage;
        return browserLang.startsWith('es') ? 'es' : 'en';
    }

    t(key) {
        const keys = key.split('.');
        let value = this.translations[this.currentLanguage];
        for (const k of keys) {
            value = value[k];
            if (value === undefined) return key;
        }
        return value;
    }

    setLanguage(lang) {
        if (this.translations[lang]) {
            this.currentLanguage = lang;
            this.updateUILanguage();
        }
    }

    updateUILanguage() {
        // Update header
        document.querySelector('.header h1').textContent = this.t('title');
        document.querySelector('.header p').textContent = this.t('subtitle');

        // Update buttons
        const trackBtn = document.getElementById('track-latest-btn');
        if (trackBtn) {
            trackBtn.querySelector('span:last-child').textContent = 
                this.isTrackingLatest ? this.t('trackLatest') : this.t('trackingOff');
        }

        document.querySelector('#history-mode-btn span:last-child').textContent = this.t('historyMode');
        document.querySelector('#history-config-btn span:last-child').textContent = this.t('historySettings');
        document.querySelector('#live-mode-btn span:last-child').textContent = this.t('liveMode');
        document.querySelector('#menu-toggle-btn span:last-child').textContent = this.t('menu');

        // Update mode indicator
        const modeIndicator = document.getElementById('mode-indicator');
        if (this.isHistoryMode) {
            modeIndicator.innerHTML = `<div class="mode-indicator-dot"></div><span>${this.t('historyModeBadge')}</span>`;
        } else {
            modeIndicator.innerHTML = `<div class="mode-indicator-dot"></div><span>${this.t('liveModeBadge')}</span>`;
        }

        // Update popup menu
        document.querySelector('#popup-menu .popup-header h2').textContent = this.t('controlsAndInfo');
        document.querySelector('[data-tab="controls"]').textContent = this.t('controls');
        document.querySelector('[data-tab="locations"]').textContent = this.t('locations');

        // Update controls tab
        document.querySelector('label[for="device-filter"]').textContent = this.t('filterByDevice');
        document.querySelector('label[for="history-limit"]').textContent = this.t('historyLimit');
        document.getElementById('refresh-data-btn').textContent = 
            this.isHistoryMode ? this.t('refreshDataHistorical') : this.t('refreshData');

        document.getElementById('trace-dots-label').textContent = this.t('showTraceDots');

        // Update history config popup
        document.querySelector('#history-config-popup .popup-header h2').textContent = this.t('historicalViewConfig');
        document.querySelector('label[for="start-time-popup"]').textContent = this.t('from');
        document.querySelector('label[for="end-time-popup"]').textContent = this.t('to');
        document.getElementById('apply-time-filter-popup').textContent = this.t('applyTimeFilter');
        document.getElementById('clear-time-filter-popup').textContent = this.t('clearFilter');
        
        // Update no filter overlay
        const noFilterTitle = document.getElementById('no-filter-title');
        const noFilterMessage = document.getElementById('no-filter-message');
        const noFilterBtnText = document.getElementById('no-filter-btn-text');
        const noFilterDismissText = document.getElementById('no-filter-dismiss-text');

        if (noFilterTitle) noFilterTitle.textContent = this.t('noFilterTitle');
        if (noFilterMessage) noFilterMessage.textContent = this.t('noFilterMessage');
        if (noFilterBtnText) noFilterBtnText.textContent = this.t('openHistorySettings');
        if (noFilterDismissText) noFilterDismissText.textContent = this.t('dismiss');
        
        // Update empty results popup
        document.querySelector('#empty-results-popup h3').textContent = this.t('noResultsTitle');
        document.querySelector('#empty-results-popup p').textContent = this.t('noResultsMessage');
        document.querySelector('#empty-results-popup .btn').textContent = this.t('ok');
        
        // Update route legend
        const legendStart = document.getElementById('legend-start');
        const legendEnd = document.getElementById('legend-end');
        if (legendStart) legendStart.textContent = this.t('legendStart');
        if (legendEnd) legendEnd.textContent = this.t('legendEnd');
        
        // Update history config popup tabs
        const timeFilterTabBtn = document.querySelector('#time-filter-tab-label');
        const locationFilterTabBtn = document.querySelector('#location-filter-tab-label');
        if (timeFilterTabBtn) timeFilterTabBtn.textContent = this.t('timeFilterTabLabel');
        if (locationFilterTabBtn) locationFilterTabBtn.textContent = this.t('locationFilterTabLabel');

        // Update location filter labels
        const locationLatLabel = document.getElementById('location-lat-label');
        const locationLngLabel = document.getElementById('location-lng-label');
        const locationRadiusLabel = document.getElementById('location-radius-label');
        const applyLocationBtn = document.getElementById('apply-location-filter');
        const clearLocationBtn = document.getElementById('clear-location-filter');

        if (locationLatLabel) locationLatLabel.textContent = this.t('latitude');
        if (locationLngLabel) locationLngLabel.textContent = this.t('longitude');
        if (locationRadiusLabel) locationRadiusLabel.textContent = this.t('radiusKm');
        if (applyLocationBtn) applyLocationBtn.textContent = this.t('applyLocationFilter');
        if (clearLocationBtn) clearLocationBtn.textContent = this.t('clearFilter');

        // Refresh displays
        this.updateConnectionStatus(
            this.ws && this.ws.readyState === WebSocket.OPEN ? this.t('connected') : this.t('connecting'),
            this.ws && this.ws.readyState === WebSocket.OPEN ? 'connected' : 'disconnected'
        );
        this.updateTimeFilterIndicator();
        this.displayLocations();
        this.updateDevicesList();
    }

    async initializeApp() {
        try {
            this.initializeMap();
            this.setupEventListeners();
            this.setupPopupMenu();
            await this.loadInitialData();
            this.connectWebSocket();
            this.startStatsPolling();
            this.initializeTimePickers();
            this.updateRefreshButtonState();
            this.updateTimeFilterIndicator();
            this.updateUILanguage();
            document.getElementById('language-selector').value = this.currentLanguage;
        } catch (error) {
            console.error('Failed to initialize app:', error);
            this.showError('Failed to initialize application');
        }
    }

    initializeMap() {
        this.map = new maplibregl.Map({
            container: 'map',
            style: this.config.mapStyle,
            center: this.config.defaultCenter,
            zoom: this.config.defaultZoom,
            attributionControl: true
        });

        this.map.addControl(new maplibregl.NavigationControl(), 'bottom-left');
        this.map.addControl(new maplibregl.FullscreenControl(), 'bottom-left');

        this.map.on('dragstart', () => {
            if (!this.suppressUserInteraction) this.handleUserInteraction();
        });

        this.map.on('zoomstart', () => {
            if (!this.suppressUserInteraction) this.handleUserInteraction();
        });

        this.map.on('movestart', () => {
            if (!this.suppressUserInteraction) this.handleUserInteraction();
        });

        this.map.on('load', () => {
            this.initializeRouteLine();
            this.routeCoords = this.locations.map(loc => [loc.longitude, loc.latitude]);
            this.updateRouteLine();
            console.log('Map loaded successfully');
        });

        this.map.on('error', (e) => {
            console.error('Map error:', e);
        });
    }

    setupPopupMenu() {
        const menuToggle = document.getElementById('menu-toggle-btn');
        const popupMenu = document.getElementById('popup-menu');
        const popupClose = document.getElementById('popup-close');
        
        // History config popup elements
        const historyConfigPopup = document.getElementById('history-config-popup');
        const historyConfigClose = document.getElementById('history-config-close');
        
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabContents = document.querySelectorAll('.tab-content');

        // Toggle main menu
        menuToggle.addEventListener('click', () => {
            popupMenu.classList.add('active');
        });

        // Close main menu
        const closeMenu = () => {
            popupMenu.classList.remove('active');
        };

        // Close history config popup
        const closeHistoryConfig = () => {
            historyConfigPopup.classList.remove('active');
        };

        popupClose.addEventListener('click', closeMenu);
        historyConfigClose.addEventListener('click', closeHistoryConfig);

        // Close when clicking outside content
        popupMenu.addEventListener('click', (e) => {
            if (e.target === popupMenu) {
                closeMenu();
            }
        });

        historyConfigPopup.addEventListener('click', (e) => {
            if (e.target === historyConfigPopup) {
                closeHistoryConfig();
            }
        });

        // Tab switching
        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                const tabId = button.dataset.tab;
                
                // Update button states
                tabButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                
                // Update content visibility
                tabContents.forEach(content => {
                    content.classList.remove('active');
                    if (content.id === `${tabId}-tab`) {
                        content.classList.add('active');
                    }
                });
            });
        });

        // Close menus with Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (popupMenu.classList.contains('active')) {
                    closeMenu();
                }
                if (historyConfigPopup.classList.contains('active')) {
                    closeHistoryConfig();
                }
            }
        });
    }

    handleUserInteraction() {
        // ignore programmatic moves
        if (this.suppressUserInteraction) return;

        if (!this.userInteracted) {
            this.userInteracted = true;
            if (this.isTrackingLatest) {
                this.toggleTracking(false);
            }
        }
    }

    initializeRouteLine() {
        // Remove existing route layers and source
        if (this.map.getSource('route')) {
            if (this.map.getLayer('route-line')) {
                this.map.removeLayer('route-line');
            }
            this.map.removeSource('route');
        }

        // Remove any existing segment layers
        for (let i = 0; i < 100; i++) {
            if (this.map.getLayer(`route-segment-${i}`)) {
                this.map.removeLayer(`route-segment-${i}`);
            }
        }

        this.map.addSource('route', {
            type: 'geojson',
            data: {
                type: 'FeatureCollection',
                features: []
            }
        });
    }

    updateRouteLine() {
        if (!this.map.getSource('route')) return;
        
        const coordinates = this.routeCoords;
        
        if (coordinates.length < 2) {
            // Remove all segment layers
            for (let i = 0; i < 100; i++) {
                if (this.map.getLayer(`route-segment-${i}`)) {
                    this.map.removeLayer(`route-segment-${i}`);
                }
            }
            this.map.getSource('route').setData({
                type: 'FeatureCollection',
                features: []
            });
            this.updateRouteLegend();
            return;
        }

        // Create colored segments
        const features = [];
        const totalSegments = coordinates.length - 1;

        // NOTE: coordinates array is ordered from NEWEST to OLDEST (index 0 = newest, last index = oldest)
        // We want: oldest (last index) = GREEN, newest (index 0) = RED

        for (let i = 0; i < totalSegments; i++) {
            // Calculate progress: 0 = oldest (green), 1 = newest (red)
        // Since array is reversed (newest first), we need to invert the progress
            const progress = 1 - (i / totalSegments);

            // Calculate color based on progress
            // progress = 0 (oldest) -> Green #10b981
            // progress = 0.5 (middle) -> Orange #f59e0b  
            // progress = 1 (newest) -> Red #ef4444
            let color;
            if (progress < 0.5) {
                // Green to Orange (oldest to middle)
                const localProgress = progress * 2;
                const r = Math.round(16 + (245 - 16) * localProgress);
                const g = Math.round(185 - (185 - 158) * localProgress);
                const b = Math.round(129 - (129 - 11) * localProgress);
                color = `rgb(${r}, ${g}, ${b})`;
            } else {
                // Orange to Red (middle to newest)
                const localProgress = (progress - 0.5) * 2;
                const r = Math.round(245 + (239 - 245) * localProgress);
                const g = Math.round(158 - (158 - 68) * localProgress);
                const b = Math.round(11 + (68 - 11) * localProgress);
                color = `rgb(${r}, ${g}, ${b})`;
            }

            features.push({
                type: 'Feature',
                properties: {
                    color: color,
                    segmentIndex: i
                },
                geometry: {
                    type: 'LineString',
                    coordinates: [coordinates[i], coordinates[i + 1]]
                }
            });
        }

        // Remove existing segment layers
        for (let i = 0; i < 100; i++) {
            if (this.map.getLayer(`route-segment-${i}`)) {
                this.map.removeLayer(`route-segment-${i}`);
            }
        }

        // Update source data
        this.map.getSource('route').setData({
            type: 'FeatureCollection',
            features: features
        });

        // Add layers for each segment with its specific color
        features.forEach((feature, index) => {
            const layerId = `route-segment-${index}`;

            if (!this.map.getLayer(layerId)) {
                this.map.addLayer({
                    id: layerId,
                    type: 'line',
                    source: 'route',
                    filter: ['==', 'segmentIndex', index],
                    layout: {
                        'line-cap': 'round',
                        'line-join': 'round'
                    },
                    paint: {
                        'line-color': feature.properties.color,
                        'line-width': 5,
                        'line-opacity': 0.8
                    }
                });
            }
        });

        this.updateRouteLegend();
    }

    updateRouteLegend() {
        const legend = document.getElementById('route-legend');
        if (!legend) return;
        
        if (this.routeCoords.length > 1) {
            legend.style.display = 'block';
        } else {
            legend.style.display = 'none';
        }
    }

    createTraceMarker(location, isStart = false, isEnd = false) {
        const popupContent = `
            <div style="font-family: system-ui; min-width: 200px;">
                <h4 style="margin: 0 0 10px 0; color: #374151;">
                    ${location.device_id}
                    ${isStart ? ' <span style="color: #10b981; font-size: 12px;">(START)</span>' : ''}
                    ${isEnd ? ' <span style="color: #ef4444; font-size: 12px;">(END)</span>' : ''}
                </h4>
                <div style="font-size: 12px; color: #6b7280; margin-bottom: 5px;">
                    <strong>Coordinates:</strong><br>
                    ${location.latitude.toFixed(6)}, ${location.longitude.toFixed(6)}
                </div>
                <div style="font-size: 12px; color: #6b7280;">
                    <strong>Time:</strong><br>
                    ${new Date(location.timestamp).toLocaleString()}
                </div>
            </div>
        `;

        const el = document.createElement('div');
        el.className = 'trace-marker';
        
        if (isStart) {
            el.classList.add('start-point');
        } else if (isEnd) {
            el.classList.add('end-point');
        }

        const marker = new maplibregl.Marker({ element: el })
            .setLngLat([location.longitude, location.latitude])
            .setPopup(new maplibregl.Popup().setHTML(popupContent))
            .addTo(this.map);

        this.traceMarkers.push(marker);
    }

    calculateBearing(lat1, lon1, lat2, lon2) {
        const dLon = (lon2 - lon1) * Math.PI / 180;
        const lat1Rad = lat1 * Math.PI / 180;
        const lat2Rad = lat2 * Math.PI / 180;
        
        const y = Math.sin(dLon) * Math.cos(lat2Rad);
        const x = Math.cos(lat1Rad) * Math.sin(lat2Rad) -
                  Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(dLon);
        
        let bearing = Math.atan2(y, x) * 180 / Math.PI;
        bearing = (bearing + 360) % 360;
        
        return bearing;
    }

    clearTraceMarkers() {
        this.traceMarkers.forEach(m => m.remove());
        this.traceMarkers = [];
    }


    initializeTimePickers() {
        const now = new Date();
        const endTime = new Date(now);
        const startTime = new Date(now - 24 * 60 * 60 * 1000); // 24 hours ago

        document.getElementById('end-time-popup').value = this.formatDateTimeLocal(endTime);
        document.getElementById('start-time-popup').value = this.formatDateTimeLocal(startTime);
    }

    formatDateTimeLocal(date) {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        return `${year}-${month}-${day}T${hours}:${minutes}`;
    }

    toggleTracking(enable = null) {
        if (enable === null) {
            this.isTrackingLatest = !this.isTrackingLatest;
        } else {
            this.isTrackingLatest = enable;
        }
        
        const btn = document.getElementById('track-latest-btn');
        if (this.isTrackingLatest) {
            btn.classList.add('enabled');
            btn.classList.remove('disabled');
            btn.querySelector('span:last-child').textContent = this.t('trackLatest');
            if (this.locations.length > 0) {
                this.centerMapOnLatestLocation();
            }
        } else {
            btn.classList.remove('enabled');
            btn.classList.add('disabled');
            btn.querySelector('span:last-child').textContent = this.t('trackingOff');
        }
    }

    toggleHistoryMode() {
        this.isHistoryMode = !this.isHistoryMode;
        const historyBtn = document.getElementById('history-mode-btn');
        const historyConfigBtn = document.getElementById('history-config-btn');
        const liveModeBtn = document.getElementById('live-mode-btn');
        const trackBtn = document.getElementById('track-latest-btn');
        const modeIndicator = document.getElementById('mode-indicator');
        // Clear any selected location markers when switching modes
        this.clearSelectedLocationMarker();
        this.selectedLocationIndex = -1;
        if (this.isHistoryMode) {        
            // Hide history mode button, show config and live mode buttons
            modeIndicator.className = 'mode-indicator history-mode';
            modeIndicator.innerHTML = `<div class="mode-indicator-dot"></div><span>${this.t('historyModeBadge')}</span>`;
            historyBtn.style.display = 'none';
            historyConfigBtn.style.display = 'flex';
            liveModeBtn.style.display = 'flex';
            trackBtn.style.display = 'none';
        
            this.toggleTracking(false);
        
            // Clear all live markers and route when entering history mode
            this.clearAllMarkers();
            this.clearTraceMarkers();
            this.routeCoords = [];
            this.updateRouteLine();
        
            if (this.persistedTimeFilter) {
                this.timeFilter = { ...this.persistedTimeFilter };
                this.activeFilterType = 'time';
                this.restoreTimePickerValues();
                this.updateTimeFilterIndicator();
                this.loadHistoricalData();
                this.hideNoFilterOverlay();
            } else {
                // Initialize with empty filtered locations (user needs to apply filter)
                this.filteredLocations = [];
                this.activeFilterType = null;
                this.displayFilteredLocations();
                this.updateTimeFilterIndicator();
                this.showNoFilterOverlay();
            }
        
        } else {
            // Update mode indicator
            modeIndicator.className = 'mode-indicator live-mode';
            modeIndicator.innerHTML = `<div class="mode-indicator-dot"></div><span>${this.t('liveModeBadge')}</span>`;

            // Store current filter before leaving history mode
            if (this.timeFilter) {
                this.persistedTimeFilter = { ...this.timeFilter };
            }
        
            // Show history mode button, hide config and live mode buttons
            historyBtn.style.display = 'flex';
            historyConfigBtn.style.display = 'none';
            liveModeBtn.style.display = 'none';
            trackBtn.style.display = 'flex';
        
            // Clear historical data
            this.clearAllMarkers();
            this.clearTraceMarkers();
            this.filteredLocations = [];
            this.updateTimeFilterIndicator();
        
            // Reset live mode: fetch latest from DB and prepare for live updates
            this.loadInitialData();
        
            // Process any queued live updates
            while (this.liveUpdateQueue.length > 0) {
                const queuedLocation = this.liveUpdateQueue.shift();
                this.applyLocationUpdate(queuedLocation);
            }
        }

        // Update refresh button state based on current mode
        this.updateRefreshButtonState();
        this.updateLocationSelection();
        this.hideNoFilterOverlay();

        // Re-apply translations after mode switch
        this.updateUILanguage();
    }

    showNoFilterOverlay() {
        console.log('showNoFilterOverlay called'); // Debug log
        const overlay = document.getElementById('no-filter-overlay');
        if (overlay) {
            console.log('Overlay found, adding show class'); // Debug log
            overlay.classList.add('show');
            // Force display
            overlay.style.display = 'block';
        } else {
            console.error('no-filter-overlay element not found!'); // Debug log
        }
    }

    hideNoFilterOverlay() {
        console.log('hideNoFilterOverlay called'); // Debug log
        const overlay = document.getElementById('no-filter-overlay');
        if (overlay) {
            overlay.classList.remove('show');
            overlay.style.display = 'none';
        }
    }

    setupEventListeners() {
        // Track Latest button
        document.getElementById('track-latest-btn').addEventListener('click', () => {
            this.userInteracted = false;
            this.suppressUserInteraction = false;
            this.selectedLocationIndex = -1;
            this.toggleTracking(true);
            this.updateLocationSelection();
        });
        // History Mode button
        document.getElementById('history-mode-btn').addEventListener('click', () => {
            this.toggleHistoryMode();
        });

        // Live Mode button (appears in history mode)
        document.getElementById('live-mode-btn').addEventListener('click', () => {
            this.toggleHistoryMode();
        });

        // History Config button
        document.getElementById('history-config-btn').addEventListener('click', () => {
            this.openHistoryConfigPopup();
        });

        document.getElementById('toggle-trace-dots').addEventListener('change', (e) => {
            this.showTraceDots = e.target.checked;
            this.applyTraceDotsVisibility();
        });

        // Device filter
        document.getElementById('device-filter').addEventListener('change', (e) => {
            this.selectedDevice = e.target.value;
            this.filterAndDisplayLocations();
            this.updateRouteForDevice();
        });

        // History limit
        document.getElementById('history-limit').addEventListener('change', (e) => {
            this.historyLimit = parseInt(e.target.value);
            this.refreshData();
        });
        document.getElementById('language-selector').addEventListener('change', (e) => {
            this.setLanguage(e.target.value);
        });

        // Refresh on window focus
        window.addEventListener('focus', () => {
            if (this.ws && this.ws.readyState !== WebSocket.OPEN) {
                this.connectWebSocket();
            }
        });
    }
    updateRefreshButtonState() {
        const refreshBtn = document.getElementById('refresh-data-btn');
        if (refreshBtn) {
            if (this.isHistoryMode) {
                refreshBtn.disabled = true;
                refreshBtn.style.opacity = '0.5';
                refreshBtn.style.cursor = 'not-allowed';
                refreshBtn.textContent = 'Refresh Data (Historical Mode)';
            } else {
                refreshBtn.disabled = false;
                refreshBtn.style.opacity = '1';
                refreshBtn.style.cursor = 'pointer';
                refreshBtn.textContent = 'Refresh Data';
            }
        }
    }
    applyTraceDotsVisibility() {
        this.traceMarkers.forEach(marker => {
            const el = marker.getElement();
            if (this.showTraceDots) {
                el.classList.add('always-visible');
            } else {
                el.classList.remove('always-visible');
            }
        });

        document.getElementById('toggle-trace-dots').checked = this.showTraceDots;
    }

    openHistoryConfigPopup() {
        console.log('Opening history config popup'); // Debug log

        const historyConfigPopup = document.getElementById('history-config-popup');
        if (!historyConfigPopup) {
            console.error('History config popup not found');
            return;
        }

        const closeBtn = historyConfigPopup.querySelector('#history-config-close');
        if (closeBtn) {
            closeBtn.onclick = () => {
                historyConfigPopup.classList.remove('active');
            };
        }

        // Initialize time pickers with current filter or defaults
        if (this.timeFilter) {
            document.getElementById('start-time-popup').value = this.formatDateTimeLocal(this.timeFilter.start);
            document.getElementById('end-time-popup').value = this.formatDateTimeLocal(this.timeFilter.end);
        } else {
            this.initializeTimePickersPopup();
        }

        // Show popup first
        historyConfigPopup.classList.add('active');

        console.log('Popup shown, setting up events'); // Debug log

        // Set up events immediately (no delay)
        this.setupConfigPopupEvents(historyConfigPopup);
    }
    
    setupConfigPopupEvents(popup) {
        console.log('Setting up config popup events'); // Debug log

        // === TIME FILTER TAB SETUP ===
        const controlsContainer = popup.querySelector('#historical-controls-popup');
        if (controlsContainer) {
            console.log('Time filter controls found'); // Debug log

            const startInput = popup.querySelector('#start-time-popup');
            const endInput = popup.querySelector('#end-time-popup');
            const applyBtn = popup.querySelector('#apply-time-filter-popup');
            const clearBtn = popup.querySelector('#clear-time-filter-popup');

            // Remove old listeners by cloning
            if (applyBtn) {
                const newApplyBtn = applyBtn.cloneNode(true);
                applyBtn.parentNode.replaceChild(newApplyBtn, applyBtn);

                newApplyBtn.addEventListener('click', () => {
                    console.log('Apply time filter clicked');
                    if (this.validateTimeFilter()) {
                        this.applyTimeFilterFromPopup();
                    }
                });
            }

            if (clearBtn) {
                const newClearBtn = clearBtn.cloneNode(true);
                clearBtn.parentNode.replaceChild(newClearBtn, clearBtn);

                newClearBtn.addEventListener('click', () => {
                    console.log('Clear time filter clicked');
                    this.clearTimeFilter();
                });
            }

            if (startInput && endInput) {
                const validateAndUpdate = () => {
                    this.validateTimeFilter();
                };

                startInput.addEventListener('change', validateAndUpdate);
                endInput.addEventListener('change', validateAndUpdate);
                startInput.addEventListener('input', validateAndUpdate);
                endInput.addEventListener('input', validateAndUpdate);
            }

            controlsContainer.querySelectorAll('.quick-range-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const hours = parseInt(e.target.dataset.hours);
                    this.setQuickTimeRange(hours);
                    controlsContainer.querySelectorAll('.quick-range-btn').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    setTimeout(() => this.validateTimeFilter(), 100);
                });
            });

            setTimeout(() => this.validateTimeFilter(), 200);
        } else {
            console.error('Time filter controls container not found!');
        }

        // === TAB SWITCHING SETUP ===
        const tabButtons = popup.querySelectorAll('.tab-button');
        const tabContents = popup.querySelectorAll('.tab-content');

        console.log('Found tab buttons:', tabButtons.length); // Debug log
        console.log('Found tab contents:', tabContents.length); // Debug log

        tabButtons.forEach(button => {
            // Remove old listeners by cloning
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);

            newButton.addEventListener('click', () => {
                const tabId = newButton.dataset.tab;
                console.log('Tab clicked:', tabId); // Debug log

                // Update button states
                popup.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                newButton.classList.add('active');

                // Update content visibility
                tabContents.forEach(content => {
                    content.classList.remove('active');
                    if (content.id === `${tabId}-tab`) {
                        content.classList.add('active');
                        console.log('Activated tab:', content.id); // Debug log
                    }
                });
            });
        });

        // === LOCATION FILTER TAB SETUP ===
        const locationTab = popup.querySelector('#location-filter-tab');
        console.log('Location filter tab found:', !!locationTab); // Debug log

        if (locationTab) {
            const latInput = locationTab.querySelector('#location-lat-input');
            const lngInput = locationTab.querySelector('#location-lng-input');
            const radiusInput = locationTab.querySelector('#location-radius-input');
            const applyLocationBtn = locationTab.querySelector('#apply-location-filter');
            const clearLocationBtn = locationTab.querySelector('#clear-location-filter');
            const errorElement = locationTab.querySelector('#location-validation-error');

            console.log('Location filter elements:', {
                latInput: !!latInput,
                lngInput: !!lngInput,
                radiusInput: !!radiusInput,
                applyLocationBtn: !!applyLocationBtn,
                clearLocationBtn: !!clearLocationBtn,
                errorElement: !!errorElement
            }); // Debug log

            if (applyLocationBtn) {
                // Remove old listener by cloning
                const newApplyLocationBtn = applyLocationBtn.cloneNode(true);
                applyLocationBtn.parentNode.replaceChild(newApplyLocationBtn, applyLocationBtn);

                newApplyLocationBtn.addEventListener('click', () => {
                    console.log('Apply location filter clicked');
                
                    const lat = parseFloat(latInput.value);
                    const lng = parseFloat(lngInput.value);
                    const radius = parseFloat(radiusInput.value);
                
                    console.log('Location filter values:', { lat, lng, radius });
                
                    if (isNaN(lat) || isNaN(lng)) {
                        console.log('Invalid lat/lng');
                        this.showValidationError('validLocationRequired', newApplyLocationBtn, errorElement);
                        return;
                    }
                
                    if (lat < -90 || lat > 90 || lng < -180 || lng > 180) {
                        console.log('Coordinates out of range');
                        this.showValidationError('invalidCoordinates', newApplyLocationBtn, errorElement);
                        return;
                    }
                
                    if (isNaN(radius) || radius <= 0) {
                        console.log('Invalid radius');
                        this.showValidationError('invalidRadius', newApplyLocationBtn, errorElement);
                        return;
                    }
                
                    console.log('Validation passed, loading historical by location');
                    this.clearValidationError(newApplyLocationBtn, errorElement);

                    // Clear time filter inputs when applying location filter
                    document.getElementById('start-time-popup').value = '';
                    document.getElementById('end-time-popup').value = '';
                    document.querySelectorAll('.quick-range-btn').forEach(btn => btn.classList.remove('active'));

                    this.loadHistoricalByLocation(lat, lng, radius);
                    popup.classList.remove('active');
                });
            } else {
                console.error('Apply location button not found!');
            }

            if (clearLocationBtn) {
                // Remove old listener by cloning
                const newClearLocationBtn = clearLocationBtn.cloneNode(true);
                clearLocationBtn.parentNode.replaceChild(newClearLocationBtn, clearLocationBtn);

                newClearLocationBtn.addEventListener('click', () => {
                    console.log('Clear location filter clicked');

                    latInput.value = '';
                    lngInput.value = '';
                    radiusInput.value = '0.5';
                    this.clearValidationError(newApplyLocationBtn, errorElement);

                    // Clear location filter state
                    this.locationFilter = null;
                    this.activeFilterType = null;
                    this.filteredLocations = [];
                    this.clearAllMarkers();
                    this.clearTraceMarkers();
                    this.routeCoords = [];
                    this.updateRouteLine();
                    this.displayFilteredLocations();
                    this.updateTimeFilterIndicator();
                    this.showNoFilterOverlay();
                });
            }
        } else {
            console.error('Location filter tab not found!');
        }
    }
    // Add this method after setupConfigPopupEvents
    restoreTimePickerValues() {
        if (this.persistedTimeFilter) {
            document.getElementById('start-time-popup').value = this.formatDateTimeLocal(this.persistedTimeFilter.start);
            document.getElementById('end-time-popup').value = this.formatDateTimeLocal(this.persistedTimeFilter.end);
            this.updateTimeFilterIndicator(); // Add this line
        }
    }

    validateTimeFilter() {
        const startInput = document.getElementById('start-time-popup');
        const endInput = document.getElementById('end-time-popup');
        const errorElement = document.getElementById('validation-error');
        const applyBtn = document.getElementById('apply-time-filter-popup');

        if (!startInput || !endInput) return false;

        const startValue = startInput.value;
        const endValue = endInput.value;

        if (!startValue || !endValue) {
            this.showValidationError('Both start and end times are required', applyBtn, errorElement);
            return false;
        }

        const startTime = new Date(startValue);
        const endTime = new Date(endValue);
        const now = new Date();

        // Check if dates are valid
        if (isNaN(startTime.getTime()) || isNaN(endTime.getTime())) {
            this.showValidationError('Invalid date format', applyBtn, errorElement);
            return false;
        }

        // Check if start is after end
        if (startTime >= endTime) {
            this.showValidationError('Start time must be before end time', applyBtn, errorElement);
            return false;
        }

        // Check if end time is in the future (with 1 minute tolerance)
        if (endTime > new Date(now.getTime() + 60000)) {
            this.showValidationError('End time cannot be in the future', applyBtn, errorElement);
            return false;
        }

        // Check if time range is too large (more than 1 year)
        const maxDuration = 365 * 24 * 60 * 60 * 1000;
        if (endTime.getTime() - startTime.getTime() > maxDuration) {
            this.showValidationError('Time range cannot exceed 1 year', applyBtn, errorElement);
            return false;
        }

        // Check if time range is too small (less than 1 minute)
        const minDuration = 60 * 1000;
        if (endTime.getTime() - startTime.getTime() < minDuration) {
            this.showValidationError('Time range must be at least 1 minute', applyBtn, errorElement);
            return false;
        }

        // Check if start time is too far in the past (more than 10 years)
        const tenYearsAgo = new Date(now.getTime() - 10 * 365 * 24 * 60 * 60 * 1000);
        if (startTime < tenYearsAgo) {
            this.showValidationError('Start time cannot be more than 10 years ago', applyBtn, errorElement);
            return false;
        }

        // All validations passed
        this.clearValidationError(applyBtn, errorElement);
        return true;
    }
    
    updateTimeFilterIndicator() {
        const indicator = document.getElementById('time-filter-indicator');
        const textElement = document.getElementById('time-filter-text');

        if (this.isHistoryMode) {
            indicator.classList.remove('time-filter-active', 'location-filter-active');

            if (this.activeFilterType === 'time' && this.timeFilter) {
                const startStr = this.timeFilter.start.toLocaleDateString() + ' ' + 
                                this.timeFilter.start.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                const endStr = this.timeFilter.end.toLocaleDateString() + ' ' + 
                              this.timeFilter.end.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                textElement.innerHTML = `<div><strong>⏱️ Time Filter:</strong> ${startStr}</div><div>${this.t('to')} ${endStr}</div>`;
                indicator.classList.add('time-filter-active');
                indicator.classList.add('show');
            } else if (this.activeFilterType === 'location' && this.locationFilter) {
                textElement.innerHTML = `<div><strong>📍 Location Filter:</strong></div><div>Lat: ${this.locationFilter.lat.toFixed(6)}, Lng: ${this.locationFilter.lng.toFixed(6)}</div><div>Radius: ${this.locationFilter.radius} km</div>`;
                indicator.classList.add('location-filter-active');
                indicator.classList.add('show');
            } else {
                indicator.classList.remove('show');
            }
        } else {
            indicator.classList.remove('show');
        }
    }
    
    showValidationError(message, button, errorElement) {
        // Translate validation error if it's a key
        let translatedMessage = message;

        // Check if it's a validation error key
        if (message === 'validLocationRequired' || message === 'invalidCoordinates' || message === 'invalidRadius') {
            translatedMessage = this.t(message);
        } else {
            // Check if it's in validationErrors object
            const validationKey = `validationErrors.${message}`;
            const translated = this.t(validationKey);
            if (translated !== validationKey) {
                translatedMessage = translated;
            }
        }

        errorElement.textContent = translatedMessage;
        errorElement.classList.add('show');
        button.disabled = true;
        button.title = translatedMessage;
    }

    clearValidationError(button, errorElement) {
        errorElement.classList.remove('show');
        button.disabled = false;
        button.title = '';
    }

    showEmptyResultsPopup() {
        document.getElementById('empty-results-popup').classList.add('show');
    }

    closeEmptyResultsPopup() {
        document.getElementById('empty-results-popup').classList.remove('show');
    }
    ensureConfigPopupIntegrity() {
        const historyConfigPopup = document.getElementById('history-config-popup');
        if (!historyConfigPopup) return;

        // Check if the popup body has been corrupted
        const popupBody = historyConfigPopup.querySelector('.popup-body');
        if (!popupBody || popupBody.offsetHeight === 0) {
            // Restore the popup structure
            const newContent = `
                <div class="popup-body" style="min-height: 300px; display: block;">
                    <div class="history-config-content" style="padding: 30px; display: block;">
                        <div class="card">
                            <div class="card-body">
                                <div class="historical-controls active" id="historical-controls-popup">
                                    <div class="quick-ranges">
                                        <button class="quick-range-btn" data-hours="1">1h</button>
                                        <button class="quick-range-btn" data-hours="6">6h</button>
                                        <button class="quick-range-btn" data-hours="24">24h</button>
                                        <button class="quick-range-btn" data-hours="168">1w</button>
                                        <button class="quick-range-btn" data-hours="0">All</button>
                                    </div>
                                    <div class="time-range-controls">
                                        <div class="control-group">
                                            <label for="start-time-popup">From:</label>
                                            <input type="datetime-local" id="start-time-popup">
                                        </div>
                                        <div class="control-group">
                                            <label for="end-time-popup">To:</label>
                                            <input type="datetime-local" id="end-time-popup">
                                        </div>
                                    </div>
                                    <div class="validation-error" id="validation-error"></div>
                                    <button class="btn" id="apply-time-filter-popup">Apply Time Filter</button>
                                    <button class="btn secondary" id="clear-time-filter-popup">Clear Filter</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Replace corrupted content
            const popupContent = historyConfigPopup.querySelector('.popup-content');
            const header = popupContent.querySelector('.popup-header');
            popupContent.innerHTML = header.outerHTML + newContent;
        }
    }
    initializeTimePickersPopup() {
        const now = new Date();
        const endTime = new Date(now);
        const startTime = new Date(now - 24 * 60 * 60 * 1000); // 24 hours ago

        document.getElementById('end-time-popup').value = this.formatDateTimeLocal(endTime);
        document.getElementById('start-time-popup').value = this.formatDateTimeLocal(startTime);
    }

    setQuickTimeRange(hours) {
        const now = new Date();
        const endTime = new Date(now);
        
        if (hours === 0) { // All time
            const startTime = new Date(0); // Very old date
            document.getElementById('start-time-popup').value = this.formatDateTimeLocal(startTime);
        } else {
            const startTime = new Date(now - hours * 60 * 60 * 1000);
            document.getElementById('start-time-popup').value = this.formatDateTimeLocal(startTime);
        }
        
        document.getElementById('end-time-popup').value = this.formatDateTimeLocal(endTime);
    }

    applyTimeFilterFromPopup() {
        console.log('applyTimeFilterFromPopup called');

        if (!this.validateTimeFilter()) {
            console.log('Validation failed, not applying filter');
            return;
        }

        const startTime = new Date(document.getElementById('start-time-popup').value);
        const endTime = new Date(document.getElementById('end-time-popup').value);

        console.log('Applying time filter:', { start: startTime, end: endTime });

        this.timeFilter = { start: startTime, end: endTime };
        this.activeFilterType = 'time'; // Set active filter type
        this.locationFilter = null; // Clear location filter
        console.log('timeFilter set to:', this.timeFilter);

        this.updateTimeFilterIndicator();
        this.loadHistoricalData();
        this.hideNoFilterOverlay();

        // Close the popup
        document.getElementById('history-config-popup').classList.remove('active');
    }

    clearTimeFilter() {
        this.timeFilter = null;
        this.persistedTimeFilter = null;
        this.activeFilterType = null; // Clear active filter type
        this.filteredLocations = [];
        this.updateTimeFilterIndicator();
        document.querySelectorAll('.quick-range-btn').forEach(btn => btn.classList.remove('active'));

        if (this.isHistoryMode) {
            // In history mode, clear everything when filter is cleared
            this.clearAllMarkers();
            this.clearTraceMarkers();
            this.routeCoords = [];
            this.updateRouteLine();
            this.displayFilteredLocations();
            this.showNoFilterOverlay(); // Show overlay when no filter
        } else {
            // In live mode, reload live data
            this.loadInitialData();
        }

        // Close the popup if open
        document.getElementById('history-config-popup').classList.remove('active');
    }

    async loadHistoricalData() {
        if (!this.timeFilter) return;
        
        try {
            const startTimestamp = this.timeFilter.start.toISOString();
            const endTimestamp = this.timeFilter.end.toISOString();

            let url = `${this.config.apiBaseUrl}/api/locations/range?start=${startTimestamp}&end=${endTimestamp}`;
            if (this.selectedDevice) {
                url += `&device=${encodeURIComponent(this.selectedDevice)}`;
            }
        
            const response = await fetch(url);
            if (response.ok) {
                const locations = await response.json();
                this.filteredLocations = locations || [];

                // Clear all existing markers before showing historical data
                this.clearAllMarkers();

                this.displayFilteredLocations();
                this.updateRouteForFiltered();

                if (this.filteredLocations.length > 0) {
                    this.fitMapToLocations(this.filteredLocations);
                } else {
                    // Show popup for empty results
                    setTimeout(() => this.showEmptyResultsPopup(), 500);
                }
            } else {
                console.error('Failed to load historical data:', response.status);
            }
        } catch (error) {
            console.error('Error loading historical data:', error);
            this.showError('Failed to load historical data');
        }
    }
    updateRouteForDevice() {
        if (this.selectedDevice) {
            this.routeCoords = this.locations
                .filter(loc => loc.device_id === this.selectedDevice)
                .map(loc => [loc.longitude, loc.latitude]);
        } else {
            this.routeCoords = this.locations.map(loc => [loc.longitude, loc.latitude]);
        }
        this.updateRouteLine();

        // Get filtered locations
        const locs = this.selectedDevice
            ? this.locations.filter(loc => loc.device_id === this.selectedDevice)
            : this.locations;

        // Clear existing markers and arrows
        this.clearTraceMarkers();

        // Create trace markers
        if (this.isHistoryMode) {
            locs.forEach((loc, index) => {
                const isStart = index === locs.length - 1; // oldest (last in array)
                const isEnd = index === 0; // newest (first in array)
                this.createTraceMarker(loc, isStart, isEnd);
            });
        } else {
            // In live mode, create trace markers with start/end indicators
            locs.forEach((loc, index) => {
                const isStart = index === locs.length - 1; // oldest (last in array) - START
                const isEnd = index === 0; // newest (first in array) - END (handled by pulse marker)
                // Mark start point but not end (end is handled by the pulse marker)
                this.createTraceMarker(loc, isStart, false);
            });
        }


        this.applyTraceDotsVisibility();
        this.updateRouteLegend(); // Add this line
    }

    updateRouteForFiltered() {
        // Only use filtered locations for historical mode
        if (!this.isHistoryMode || this.filteredLocations.length === 0) {
            this.routeCoords = [];
            this.updateRouteLine();
            this.clearTraceMarkers();
            return;
        }   

        this.routeCoords = this.filteredLocations.map(loc => [loc.longitude, loc.latitude]);
        this.updateRouteLine(); 

        this.clearTraceMarkers();

        this.filteredLocations.forEach((loc, index) => {
            const isStart = index === this.filteredLocations.length - 1; // oldest
            const isEnd = index === 0; // newest
            this.createTraceMarker(loc, isStart, isEnd);
        });

        this.applyTraceDotsVisibility();
        this.updateRouteLegend(); // Add this line
    }
    
    async loadHistoricalByLocation(latitude, longitude, radiusKm = 0.5) {
        console.log('loadHistoricalByLocation called with:', { latitude, longitude, radiusKm });
        
        try {
            const url = `${this.config.apiBaseUrl}/api/locations/nearby?lat=${latitude}&lng=${longitude}&radius=${radiusKm}`;
            console.log('Fetching from URL:', url);
        
            const response = await fetch(url);
            console.log('Response status:', response.status);

            if (response.ok) {
                const locations = await response.json();
                console.log('Received locations:', locations.length);

                this.filteredLocations = locations || [];

                // Set location filter as active
                this.locationFilter = { lat: latitude, lng: longitude, radius: radiusKm };
                this.activeFilterType = 'location';
                this.timeFilter = null; // Clear time filter
                this.persistedTimeFilter = null;
            
                this.clearAllMarkers();
                this.displayFilteredLocations();
                this.updateRouteForFiltered();
                this.updateTimeFilterIndicator(); // Update indicator to show location filter
                this.hideNoFilterOverlay();
            
                if (this.filteredLocations.length > 0) {
                    this.fitMapToLocations(this.filteredLocations);
                } else {
                    setTimeout(() => this.showEmptyResultsPopup(), 500);
                }
            } else {
                const errorText = await response.text();
                console.error('Failed to load location data:', response.status, errorText);
                this.showError('Failed to load location data: ' + response.status);
            }
        } catch (error) {
            console.error('Error loading location data:', error);
            this.showError('Failed to load location data: ' + error.message);
        }
    }
    
    fitMapToLocations(locations) {
        if (locations.length === 0) return;

        if (locations.length === 1) {
            this.centerMapOnLocation(locations[0]);
            return;
        }

        const bounds = new maplibregl.LngLatBounds();
        locations.forEach(loc => {
            bounds.extend([loc.longitude, loc.latitude]);
        });

        this.map.fitBounds(bounds, {
            padding: 50,
            maxZoom: 15
        });
    }

    clearAllMarkers() {
        this.markers.forEach(marker => marker.remove());
        this.markers.clear();
    }

    connectWebSocket() {
        try {
            this.ws = new WebSocket(this.config.wsUrl);
            
            this.ws.onopen = () => {
                console.log('WebSocket connected');
                this.updateConnectionStatus('Connected', 'connected');
                this.reconnectAttempts = 0;
            };
            
            this.ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    this.handleLocationUpdate(data);
                } catch (error) {
                    console.error('Error parsing WebSocket message:', error);
                }
            };
            
            this.ws.onclose = (event) => {
                console.log('WebSocket disconnected:', event.code, event.reason);
                this.updateConnectionStatus('Disconnected', 'disconnected');
                this.scheduleReconnect();
            };
            
            this.ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                this.updateConnectionStatus('Connection Error', 'disconnected');
            };
        } catch (error) {
            console.error('Failed to create WebSocket connection:', error);
            this.updateConnectionStatus('Connection Failed', 'disconnected');
            this.scheduleReconnect();
        }
    }

    scheduleReconnect() {
        if (this.reconnectAttempts < this.maxReconnectAttempts) {
            this.reconnectAttempts++;
            const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);
            
            this.updateConnectionStatus(
                `Reconnecting in ${Math.ceil(delay/1000)}s... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`, 
                'reconnecting'
            );
            
            setTimeout(() => {
                this.connectWebSocket();
            }, delay);
        } else {
            this.updateConnectionStatus('Connection failed - refresh page', 'disconnected');
        }
    }

    async loadInitialData() {
        try {
            // In live mode, only fetch the latest location from DB
            const limit = this.isHistoryMode ? this.historyLimit : 1;
            const response = await fetch(`${this.config.apiBaseUrl}/api/locations/history?limit=${limit}`);
            if (response.ok) {
                const locations = await response.json();

                if (this.isHistoryMode) {
                    // History mode: load all requested locations
                    this.locations = locations || [];
                } else {
                    // Live mode: only store the initial DB location
                    this.initialDbLocation = locations.length > 0 ? locations[0] : null;
                    this.liveLocations = [];
                    this.hasReceivedLiveUpdate = false;

                    // Set locations to show only the initial one
                    this.locations = this.initialDbLocation ? [this.initialDbLocation] : [];
                }

                this.updateDevicesList();
                this.displayLocations();
                this.updateStatistics();

                // Update route and create trace markers
                this.updateRouteForDevice();

                if (this.locations.length > 0) {
                    this.updateMapMarker(this.locations[0], true);
                    if (this.isTrackingLatest) {
                        this.centerMapOnLatestLocation();
                    }
                }
            } else {
                console.error('Failed to load initial data:', response.status);
            }
        } catch (error) {
            console.error('Error loading initial data:', error);
            this.showError('Failed to load initial data');
        }
    }

    handleLocationUpdate(location) {
        console.log('Received location update:', location);
        
        // Only process new locations if not in history mode
        if (this.isHistoryMode) {
            this.liveUpdateQueue.push(location);
            return;
        }
        this.applyLocationUpdate(location);
    }

    updateMapMarker(location, isLatest = false) {
        const deviceId = location.device_id;
        let marker = this.markers.get(deviceId);
        const popupContent = `
            <div style="font-family: system-ui; min-width: 200px;">
                <h4 style="margin: 0 0 10px 0; color: #374151;">${deviceId}</h4>
                <div style="font-size: 12px; color: #6b7280; margin-bottom: 5px;">
                    <strong>Coordinates:</strong><br>
                    ${location.latitude.toFixed(6)}, ${location.longitude.toFixed(6)}
                </div>
                <div style="font-size: 12px; color: #6b7280;">
                    <strong>Time:</strong><br>
                    ${new Date(location.timestamp).toLocaleString()}
                </div>
            </div>
        `;
        
        if (!marker) {
            // Create marker if not exist
            let el;
            if (isLatest) {
                el = document.createElement('div');
                el.className = 'pulse-marker';
            }
        
            marker = new maplibregl.Marker({
                element: el || undefined,
                color: isLatest ? undefined : this.getDeviceColor(deviceId)
            })
            .setLngLat([location.longitude, location.latitude])
            .setPopup(new maplibregl.Popup().setHTML(popupContent))
            .addTo(this.map);
        
            this.markers.set(deviceId, marker);
        } else {
            // Just update existing marker
            marker.setLngLat([location.longitude, location.latitude]);
            marker.setPopup(new maplibregl.Popup().setHTML(popupContent));
        }
    
        // Ensure pulse only applies to the latest
        const el = marker.getElement();
        if (isLatest) {
            el.classList.add('pulse-marker');
            el.style.zIndex = "9999";
        } else {
            el.classList.remove('pulse-marker');
        }
    }

    applyLocationUpdate(location) {
        // Mark that we've received at least one live update
        if (!this.hasReceivedLiveUpdate) {
            this.hasReceivedLiveUpdate = true;
            // Clear the initial DB location from display
            this.locations = [];
            this.clearAllMarkers();
            this.clearTraceMarkers();
        }

        // Add to live locations
        this.liveLocations.unshift(location);

        // Prevent uncontrolled growth of live locations
        if (this.liveLocations.length > this.historyLimit) {
            this.liveLocations = this.liveLocations.slice(0, this.historyLimit);
        }

        // Update locations to show live data
        this.locations = [...this.liveLocations];

        this.devices.add(location.device_id);
        this.updateDevicesList();
        this.filterAndDisplayLocations();
        this.updateStatistics();

        if (this.selectedDevice === '' || this.selectedDevice === location.device_id) {
            this.updateMapMarker(location, !this.isHistoryMode);
            this.updateRouteForDevice(); // This will recreate trace markers
            if (this.isTrackingLatest && !this.userInteracted) {
                this.centerMapOnLocation(location);
            }
        }
    }

    getDeviceColor(deviceId) {
        const colors = ['#ef4444', '#10b981', '#3b82f6', '#f59e0b', '#8b5cf6', '#06b6d4', '#f97316'];
        const hash = deviceId.split('').reduce((a, b) => {
            a = ((a << 5) - a) + b.charCodeAt(0);
            return a & a;
        }, 0);
        return colors[Math.abs(hash) % colors.length];
    }

    centerMapOnLatestLocation() {
        if (this.locations.length > 0) {
            this.centerMapOnLocation(this.locations[0]);
        }
    }

    centerMapOnLocation(location) {
        // still mark that the user has not manually interacted
        this.userInteracted = false;

        // indicate the upcoming move is programmatic so event handlers ignore it
        this.suppressUserInteraction = true;

        this.map.flyTo({
            center: [location.longitude, location.latitude],
            zoom: Math.max(this.map.getZoom(), 12),
            duration: 800
        });

        // clear suppression when the programmatic move finishes
        this.map.once('moveend', () => {
            // tiny delay to let chained events settle
            setTimeout(() => { this.suppressUserInteraction = false; }, 50);
        });
    }

    selectLocation(locationIndex) {
            this.selectedLocationIndex = locationIndex;
            this.userInteracted = false;

            if (locationIndex >= 0) {
                this.toggleTracking(false);
                const locations = this.isHistoryMode ? this.filteredLocations : this.getFilteredLocations();
                const location = locations[locationIndex];
                if (location) {
                    this.centerMapOnLocation(location);
                    // Create a temporary marker for the selected location, don't interfere with the latest marker
                    this.showSelectedLocationMarker(location);
                }
            } else {
                // Clear any selected location marker when deselecting
                this.clearSelectedLocationMarker();
            }

            this.updateLocationSelection();
        }

    showSelectedLocationMarker(location) {
        // Remove existing selected marker if any
        this.clearSelectedLocationMarker();

        const popupContent = `
            <div style="font-family: system-ui; min-width: 200px;">
                <h4 style="margin: 0 0 10px 0; color: #374151;">${location.device_id} <span style="color: #f59e0b; font-size: 12px;">(SELECTED)</span></h4>
                <div style="font-size: 12px; color: #6b7280; margin-bottom: 5px;">
                    <strong>Coordinates:</strong><br>
                    ${location.latitude.toFixed(6)}, ${location.longitude.toFixed(6)}
                </div>
                <div style="font-size: 12px; color: #6b7280;">
                    <strong>Time:</strong><br>
                    ${new Date(location.timestamp).toLocaleString()}
                </div>
                <button onclick="locationTracker.clearSelectedLocation()" style="margin-top: 10px; background: #ef4444; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                    Clear Selection
                </button>
            </div>
        `;
        
        // Create a distinct marker for selected locations
        const el = document.createElement('div');
        el.className = 'selected-location-marker';
        el.style.cssText = `
            width: 20px;
            height: 20px;
            background: #f59e0b;
            border: 3px solid white;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(245, 158, 11, 0.6);
            cursor: pointer;
            z-index: 1002;
        `;
        
        this.selectedLocationMarker = new maplibregl.Marker({ element: el })
            .setLngLat([location.longitude, location.latitude])
            .setPopup(new maplibregl.Popup().setHTML(popupContent))
            .addTo(this.map);
        
        // Auto-show popup
        this.selectedLocationMarker.togglePopup();
    }

    clearSelectedLocationMarker() {
        if (this.selectedLocationMarker) {
            this.selectedLocationMarker.remove();
            this.selectedLocationMarker = null;
        }
    }

    clearSelectedLocation() {
        this.selectedLocationIndex = -1;
        this.clearSelectedLocationMarker();
        this.updateLocationSelection();
        // Re-enable tracking if we were tracking before
        if (!this.userInteracted) {
            this.toggleTracking(true);
        }
    }

    getFilteredLocations() {
        if (this.selectedDevice) {
            return this.locations.filter(loc => loc.device_id === this.selectedDevice);
        }
        return this.locations;
    }

    updateLocationSelection() {
        const locationItems = document.querySelectorAll('.location-item');
        locationItems.forEach((item, index) => {
            item.classList.remove('selected');
            if (index === this.selectedLocationIndex) {
                item.classList.add('selected');
            }
        });
    }

    updateDevicesList() {
        const select = document.getElementById('device-filter');
        const currentValue = select.value;
        
        select.innerHTML = '<option value="">All Devices</option>';
        
        Array.from(this.devices).sort().forEach(deviceId => {
            const option = document.createElement('option');
            option.value = deviceId;
            option.textContent = deviceId;
            select.appendChild(option);
        });
        
        select.value = currentValue;
    }

    filterAndDisplayLocations() {
        let filteredLocations = this.getFilteredLocations();
        this.displayLocations(filteredLocations);
    }

    displayLocations(locations = this.locations) {
        const container = document.getElementById('location-list');
        
        // In live mode, locations will only contain live updates after first update,
        // or the initial DB location before any updates

        if (locations.length === 0) {
            container.innerHTML = `<div class="loading">${this.t('noLocationsFound')}</div>`;
            return;
        }

        container.innerHTML = locations.slice(0, this.historyLimit).map((location, index) => `
            <div class="location-item ${index === 0 ? 'latest' : ''} ${index === this.selectedLocationIndex ? 'selected' : ''}" 
                 onclick="locationTracker.selectLocation(${index})">
                <div class="device-id">${location.device_id}</div>
                <div class="coordinates">${location.latitude.toFixed(6)}, ${location.longitude.toFixed(6)}</div>
                <div class="timestamp">${new Date(location.timestamp).toLocaleString()}</div>
            </div>
        `).join('');
        
        // Clean up any event listeners that might interfere with popups
        // Remove any orphaned quick-range-btn elements that might have been created
        const orphanedButtons = container.querySelectorAll('.quick-range-btn');
        orphanedButtons.forEach(btn => btn.remove());
    }

    displayFilteredLocations() {
        const container = document.getElementById('location-list');

        if (this.filteredLocations.length === 0) {
            container.innerHTML = `<div class="loading">${this.t('noLocationsFound')}</div>`;
            return;
        }

        container.innerHTML = this.filteredLocations.map((location, index) => `
            <div class="location-item ${index === this.selectedLocationIndex ? 'selected' : ''}" 
                 onclick="locationTracker.selectLocation(${index})">
                <div class="device-id">${location.device_id}</div>
                <div class="coordinates">${location.latitude.toFixed(6)}, ${location.longitude.toFixed(6)}</div>
                <div class="timestamp">${new Date(location.timestamp).toLocaleString()}</div>
            </div>
        `).join('');
    }

    updateStatistics() {
        document.getElementById('total-locations').textContent = this.locations.length;
        document.getElementById('active-devices').textContent = this.devices.size;
        document.getElementById('last-update').textContent = 
            this.locations.length > 0 ? new Date(this.locations[0].timestamp).toLocaleString() : '-';
    }

    updateConnectionStatus(message, status) {
        const statusElement = document.getElementById('connection-status');
        statusElement.className = `status ${status}`;

        // Translate common status messages
        let translatedMessage = message;
        const translations = {
            'Connected': this.t('connected'),
            'Connecting...': this.t('connecting'),
            'Disconnected': this.t('disconnected'),
            'Connection Error': this.t('connectionError'),
            'Connection failed - refresh page': this.t('connectionFailed')
        };

        // Check if message matches a translatable string
        if (translations[message]) {
            translatedMessage = translations[message];
        } else if (message.includes('Reconnecting in')) {
            // Handle reconnecting messages with parameters
            const match = message.match(/Reconnecting in (\d+)s\.\.\. \((\d+)\/(\d+)\)/);
            if (match) {
                translatedMessage = this.t('reconnecting')
                    .replace('{0}', match[1])
                    .replace('{1}', match[2])
                    .replace('{2}', match[3]);
            }
        }

        statusElement.querySelector('span').textContent = translatedMessage;
    }
    showError(message) {
        const container = document.getElementById('location-list');
        container.innerHTML = `<div class="error">${message}</div>`;
    }

    async refreshData() {
        try {
            if (this.isHistoryMode && this.timeFilter) {
                await this.loadHistoricalData();
            } else {
                // In live mode, reset to initial state
                this.liveLocations = [];
                this.hasReceivedLiveUpdate = false;
                await this.loadInitialData();
            }
            console.log('Data refreshed successfully');
        } catch (error) {
            console.error('Failed to refresh data:', error);
            this.showError('Failed to refresh data');
        }
    }

    startStatsPolling() {
        const fetchAndUpdate = async () => {
            try {
                const res = await fetch(`${this.config.apiBaseUrl}/api/stats`);
                if (!res.ok) return;
                const stats = await res.json();
                document.getElementById('connected-clients').textContent = stats.connected_clients ?? '-';
                document.getElementById('total-locations').textContent = stats.total_locations ?? '-';
                document.getElementById('active-devices').textContent = stats.active_devices ?? '-';
                document.getElementById('last-update').textContent = stats.last_update ? new Date(stats.last_update).toLocaleString() : '-';
            } catch (err) {
                // ignore transient errors
            }
        };

        fetchAndUpdate();
        setInterval(fetchAndUpdate, 5000);
    }
}

// Initialize the application
let locationTracker;
document.addEventListener('DOMContentLoaded', () => {
    locationTracker = new LocationTracker();
});

// Global error handler
window.addEventListener('error', (event) => {
    console.error('Global error:', event.error);
});

// Handle page visibility changes
document.addEventListener('visibilitychange', () => {
    if (!document.hidden && locationTracker) {
        if (!locationTracker.ws || locationTracker.ws.readyState !== WebSocket.OPEN) {
            locationTracker.connectWebSocket();
        }
    }
});
</script>
</body>
</html>