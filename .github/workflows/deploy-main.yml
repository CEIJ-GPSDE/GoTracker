name: Deploy Main Branch

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      deploy_to_EC2_1:
        description: "Deploy to EC2_1"
        type: boolean
        default: true
      deploy_to_EC2_2:
        description: "Deploy to EC2_2"
        type: boolean
        default: true
      deploy_to_EC2_3:
        description: "Deploy to EC2_3"
        type: boolean
        default: true
      deploy_to_EC2_4:
        description: "Deploy to EC2_4"
        type: boolean
        default: true
      force_rebuild:
        description: "Force rebuild even if no changes"
        type: boolean
        default: false

jobs:
  deploy-main:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        instance: [EC2_1, EC2_2, EC2_3, EC2_4]
      fail-fast: false
    steps:
      - name: Determine deployment
        id: should_deploy
        run: |
          if [ "${{ github.event_name }}" = "push" ]; then
            echo "deploy=true" >> $GITHUB_OUTPUT
            echo "Deploying ${{ matrix.instance }} (triggered by push)"
          elif [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            case "${{ matrix.instance }}" in
              "EC2_1")
                deploy="${{ github.event.inputs.deploy_to_EC2_1 }}"
                ;;
              "EC2_2")
                deploy="${{ github.event.inputs.deploy_to_EC2_2 }}"
                ;;
              "EC2_3")
                deploy="${{ github.event.inputs.deploy_to_EC2_3 }}"
                ;;
              "EC2_4")
                deploy="${{ github.event.inputs.deploy_to_EC2_4 }}"
                ;;
            esac
            echo "deploy=$deploy" >> $GITHUB_OUTPUT
            echo "Deploying ${{ matrix.instance }}: $deploy (manual trigger)"
          else
            echo "deploy=false" >> $GITHUB_OUTPUT
            echo "Unknown event type, skipping deployment"
          fi

      - name: Skip unchecked instances
        if: steps.should_deploy.outputs.deploy != 'true'
        run: echo "Skipping ${{ matrix.instance }} - not selected for deployment"

      - uses: actions/checkout@v4
        if: steps.should_deploy.outputs.deploy == 'true'

      - name: Set safe branch name and instance info
        if: steps.should_deploy.outputs.deploy == 'true'
        id: prepare
        run: |
          branch="${{ github.event.inputs.branch }}"
          safe_branch=$(echo "$branch" | tr '/' '-' | tr '[:upper:]' '[:lower:]')
          echo "safe_branch=$safe_branch" >> $GITHUB_OUTPUT
          echo "Branch: $branch -> Safe: $safe_branch"
          echo "Instance: ${{ matrix.instance }}"

      - name: Modify HTML with instance name
        if: steps.should_deploy.outputs.deploy == 'true'
        run: |
          instance_name="${{ secrets[format('{0}_PAGE_NAME', matrix.instance)] }}"
          branch="${{ github.event.inputs.branch }}"
          
          # Default to matrix.instance if secret is not set
          if [ -z "$instance_name" ]; then
            instance_name="${{ matrix.instance }}"
          fi
          
          echo "Using instance name: $instance_name"
          echo "Branch: $branch"      

          ls
          
          # Modify the HTML title
          sed -i "s|<title>Real-time Location Tracker</title>|<title>$instance_name</title>|g" ./static/index.html
          
          # Update the h1 in HTML
          sed -i "s|<h1>üåç Real-time Location Tracker</h1>|<h1>üåç $instance_name</h1>|g" ./static/index.html
          
          # Update the translation objects in app.js (both English and Spanish)
          sed -i "s|title: \"üåç Real-time Location Tracker\"|title: \"üåç $instance_name\"|g" ./static/app.js
          sed -i "s|title: \"üåç Rastreador de Ubicaci√≥n en Tiempo Real\"|title: \"üåç $instance_name\"|g" ./static/app.js
          
          echo "HTML modifications completed"

      - name: Build Docker image
        if: steps.should_deploy.outputs.deploy == 'true'
        run: |
          echo "Building Docker image for main branch"
          docker build \
            --build-arg VERSION=main-$(git rev-parse --short HEAD) \
            --build-arg BASE_PATH= \
            -t location-tracker:main \
            .
          docker save location-tracker:main > location-tracker-main.tar
          echo "Docker image saved: location-tracker-main.tar"
          ls -la location-tracker-main.tar

      - name: Stop existing container and clean main deployment
        if: steps.should_deploy.outputs.deploy == 'true'
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets[format('{0}_HOST', matrix.instance)] }}
          username: ${{ secrets[format('{0}_USER', matrix.instance)] }}
          key: ${{ secrets[format('{0}_SSH_KEY', matrix.instance)] }}
          script: |
            echo "Cleaning up existing main deployment..."
            
            # Stop and remove location-tracker-main container only
            if docker ps -a --format '{{.Names}}' | grep -q "^location-tracker-main$"; then
              echo "Stopping existing container: location-tracker-main"
              docker stop location-tracker-main || echo "Container was not running"
              docker rm -f location-tracker-main || echo "Failed to remove container"
            fi
            
            # Remove location-tracker:main image
            if docker images --format '{{.Repository}}:{{.Tag}}' | grep -q "^location-tracker:main$"; then
              echo "Removing old image: location-tracker:main"
              docker rmi -f location-tracker:main || echo "Failed to remove image"
            fi
            
            # Check for and free port 8080
            echo "Checking for processes using port 8080..."
            if sudo lsof -i :8080 2>/dev/null; then
              echo "Found processes using port 8080, attempting to terminate..."
              sudo lsof -i :8080 | awk 'NR>1 {print $2}' | xargs -r sudo kill -9 || echo "Failed to terminate some processes"
              sleep 2
            fi
            
            mkdir -p /home/ec2-user/certs
            mkdir -p /home/ec2-user/logs
            echo "Main cleanup completed"

      - name: Upload Docker image
        if: steps.should_deploy.outputs.deploy == 'true'
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets[format('{0}_HOST', matrix.instance)] }}
          username: ${{ secrets[format('{0}_USER', matrix.instance)] }}
          key: ${{ secrets[format('{0}_SSH_KEY', matrix.instance)] }}
          source: location-tracker-main.tar
          target: /tmp/

      - name: Deploy SSL certificates
        if: steps.should_deploy.outputs.deploy == 'true'
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets[format('{0}_HOST', matrix.instance)] }}
          username: ${{ secrets[format('{0}_USER', matrix.instance)] }}
          key: ${{ secrets[format('{0}_SSH_KEY', matrix.instance)] }}
          script: |
            sudo mkdir -p /etc/ssl/certs /etc/ssl/private
            mkdir -p /home/ec2-user/certs
            if [ -n "${{ secrets[format('{0}_SSL_CERT', matrix.instance)] }}" ]; then
              echo "Deploying SSL certificate..."
              echo "${{ secrets[format('{0}_SSL_CERT', matrix.instance)] }}" | sudo tee /etc/ssl/certs/location-tracker.crt > /dev/null
              sudo chmod 644 /etc/ssl/certs/location-tracker.crt
              echo "${{ secrets[format('{0}_SSL_CERT', matrix.instance)] }}" > /home/ec2-user/certs/server.crt
              chmod 644 /home/ec2-user/certs/server.crt
            fi
            if [ -n "${{ secrets[format('{0}_SSL_KEY', matrix.instance)] }}" ]; then
              echo "Deploying SSL private key..."
              echo "${{ secrets[format('{0}_SSL_KEY', matrix.instance)] }}" | sudo tee /etc/ssl/private/location-tracker.key > /dev/null
              sudo chmod 600 /etc/ssl/private/location-tracker.key
              sudo chown root:root /etc/ssl/private/location-tracker.key
              echo "${{ secrets[format('{0}_SSL_KEY', matrix.instance)] }}" > /home/ec2-user/certs/server.key
              chmod 600 /home/ec2-user/certs/server.key
            fi
            echo "SSL certificates deployed successfully"

      - name: Create modular Nginx configuration
        if: steps.should_deploy.outputs.deploy == 'true'
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets[format('{0}_HOST', matrix.instance)] }}
          username: ${{ secrets[format('{0}_USER', matrix.instance)] }}
          key: ${{ secrets[format('{0}_SSH_KEY', matrix.instance)] }}
          script: |
            domain="${{ secrets[format('{0}_DOMAIN', matrix.instance)] }}"
            echo "Creating modular Nginx configuration for domain: $domain"
            
            # Create directories for modular configuration
            sudo mkdir -p /etc/nginx/conf.d/location-tracker
            
            # Remove old unified config if it exists
            sudo rm -f /etc/nginx/conf.d/location-tracker-*.conf
            
            # Create base server configuration
            cat > /tmp/nginx-base.conf << 'NGINX_EOF'
            # Base server configuration for main application
            server {
                listen 80;
                server_name DOMAIN_PLACEHOLDER;
                
                # Main application (root path) - redirect to HTTPS if certs exist
                location / {
                    if (-f /etc/ssl/certs/location-tracker.crt) {
                        return 301 https://$server_name$request_uri;
                    }
                    proxy_pass http://127.0.0.1:8080;
                    proxy_http_version 1.1;
                    proxy_set_header Upgrade $http_upgrade;
                    proxy_set_header Connection 'upgrade';
                    proxy_set_header Host $host;
                    proxy_set_header X-Real-IP $remote_addr;
                    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto $scheme;
                    proxy_cache_bypass $http_upgrade;
                }
                
                # WebSocket for main app
                location /ws {
                    if (-f /etc/ssl/certs/location-tracker.crt) {
                        return 301 https://$server_name$request_uri;
                    }
                    proxy_pass http://127.0.0.1:8080/ws;
                    proxy_http_version 1.1;
                    proxy_set_header Upgrade $http_upgrade;
                    proxy_set_header Connection "Upgrade";
                    proxy_set_header Host $host;
                    proxy_set_header X-Real-IP $remote_addr;
                    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto $scheme;
                }
            
                # Include development and feature branch configurations
                include /etc/nginx/conf.d/location-tracker/dev-*.conf;
                include /etc/nginx/conf.d/location-tracker/feature-*.conf;
            }
            NGINX_EOF
            
            # Add HTTPS server block if certificates exist
            if [ -f /etc/ssl/certs/location-tracker.crt ] && [ -f /etc/ssl/private/location-tracker.key ]; then
              echo "SSL certificates found, adding HTTPS configuration..."
              
              cat >> /tmp/nginx-base.conf << 'NGINX_HTTPS_EOF'
            
            # HTTPS server block
            server {
                listen 443 ssl;
                http2 on;
                server_name DOMAIN_PLACEHOLDER;
                
                ssl_certificate /etc/ssl/certs/location-tracker.crt;
                ssl_certificate_key /etc/ssl/private/location-tracker.key;
                ssl_protocols TLSv1.2 TLSv1.3;
                ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384;
                ssl_prefer_server_ciphers off;
                ssl_session_cache shared:SSL:10m;
                ssl_session_timeout 10m;
                
                add_header X-Frame-Options DENY;
                add_header X-Content-Type-Options nosniff;
                add_header X-XSS-Protection "1; mode=block";
                add_header Strict-Transport-Security "max-age=31536000; includeSubDomains";
                add_header Referrer-Policy "strict-origin-when-cross-origin";
                
                # Main application (root path)
                location / {
                    proxy_pass http://127.0.0.1:8080;
                    proxy_http_version 1.1;
                    proxy_set_header Upgrade $http_upgrade;
                    proxy_set_header Connection 'upgrade';
                    proxy_set_header Host $host;
                    proxy_set_header X-Real-IP $remote_addr;
                    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto $scheme;
                    proxy_cache_bypass $http_upgrade;
                }
                
                # WebSocket for main app
                location /ws {
                    proxy_pass http://127.0.0.1:8080/ws;
                    proxy_http_version 1.1;
                    proxy_set_header Upgrade $http_upgrade;
                    proxy_set_header Connection "Upgrade";
                    proxy_set_header Host $host;
                    proxy_set_header X-Real-IP $remote_addr;
                    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto $scheme;
                }
                
                # Include development and feature branch configurations
                include /etc/nginx/conf.d/location-tracker/dev-*.conf;
                include /etc/nginx/conf.d/location-tracker/feature-*.conf;
            }
            NGINX_HTTPS_EOF
            else
              echo "No SSL certificates found, HTTP only configuration"
            fi
            
            # Replace domain placeholder
            sed -i "s/DOMAIN_PLACEHOLDER/$domain/g" /tmp/nginx-base.conf
            
            # Preserve existing feature configurations by recreating them from running containers
            running_feature_containers=""
            if docker ps --format "table {{.Names}}" | grep -q "location-tracker-"; then
              running_feature_containers=$(docker ps --format "{{.Names}}" | grep "location-tracker-" | grep -v "location-tracker-main" || echo "")
            fi
            
            echo "Preserving configurations for running containers: $running_feature_containers"
            
            # Recreate feature configurations for running containers
            if [ ! -z "$running_feature_containers" ]; then
              for container_name in $running_feature_containers; do
                if echo "$container_name" | grep -q "^location-tracker-"; then
                  safe_branch=$(echo "$container_name" | sed 's/^location-tracker-//')
                  branch=$(echo "$safe_branch" | sed 's/-/\//g')
                  
                  # Determine if it's a dev or feature branch and set appropriate port
                  if echo "$branch" | grep -q "^dev/"; then
                    container_port="8081"
                    config_type="dev"
                    location_path="/dev/$branch"
                  else
                    container_port="8082"
                    config_type="feature"
                    location_path="/test/$branch"
                  fi
                  
                  config_file="/etc/nginx/conf.d/location-tracker/${config_type}-${safe_branch}.conf"
                  
                  echo "Creating configuration for $config_type branch: $location_path"
                  
                  # Create the branch-specific configuration file
                  cat > /tmp/${config_type}-${safe_branch}.conf << EOF
            # Configuration for $config_type branch: $branch
            location $location_path/ {
                proxy_pass http://127.0.0.1:$container_port/;
                proxy_http_version 1.1;
                proxy_set_header Upgrade \$http_upgrade;
                proxy_set_header Connection 'upgrade';
                proxy_set_header Host \$host;
                proxy_set_header X-Real-IP \$remote_addr;
                proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto \$scheme;
                proxy_cache_bypass \$http_upgrade;
            }

            location $location_path/ws {
                proxy_pass http://127.0.0.1:$container_port/ws;
                proxy_http_version 1.1;
                proxy_set_header Upgrade \$http_upgrade;
                proxy_set_header Connection "Upgrade";
                proxy_set_header Host \$host;
                proxy_set_header X-Real-IP \$remote_addr;
                proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto \$scheme;
            }
            EOF
                  
                  sudo mv /tmp/${config_type}-${safe_branch}.conf $config_file
                fi
              done
            fi
            
            # Move the base configuration to the final location
            sudo mv /tmp/nginx-base.conf /etc/nginx/conf.d/location-tracker-base.conf
            
            # Test configuration
            echo "Testing nginx configuration..."
            if sudo nginx -t; then
              echo "Nginx configuration test passed"
              if sudo systemctl is-active nginx; then
                sudo systemctl reload nginx
              else
                sudo systemctl start nginx
              fi
              echo "Modular Nginx configuration created successfully"
            else
              echo "ERROR: Nginx configuration test failed"
              echo "Base configuration content:"
              sudo cat /etc/nginx/conf.d/location-tracker-base.conf
              sudo nginx -t
              exit 1
            fi


      - name: Load and start Docker container
        if: steps.should_deploy.outputs.deploy == 'true'
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets[format('{0}_HOST', matrix.instance)] }}
          username: ${{ secrets[format('{0}_USER', matrix.instance)] }}
          key: ${{ secrets[format('{0}_SSH_KEY', matrix.instance)] }}
          script: |
            echo "Loading and starting Docker container: location-tracker-main"
            
            if [ -f "/tmp/location-tracker-main.tar" ]; then
              echo "Loading Docker image from tar file..."
              docker load < /tmp/location-tracker-main.tar
            else
              echo "ERROR: Docker image tar file not found"
              exit 1
            fi
            
            echo "Starting Docker container..."
            docker run -d \
              --name location-tracker-main \
              --restart unless-stopped \
              -p 8080:8080 \
              -p 5051:5051/udp \
              -v /home/ec2-user/certs:/root/certs:ro \
              -v /home/ec2-user/logs:/var/log \
              -e DB_HOST="${{ secrets[format('{0}_DB_HOST', matrix.instance)] }}" \
              -e DB_NAME="${{ secrets[format('{0}_DB_NAME', matrix.instance)] }}" \
              -e DB_USER="${{ secrets[format('{0}_DB_USER', matrix.instance)] }}" \
              -e DB_PASSWORD="${{ secrets[format('{0}_DB_PASSWORD', matrix.instance)] }}" \
              -e DB_SSLMODE=require \
              -e PORT=8080 \
              -e UDP_PORT=5051 \
              -e DOMAIN="${{ secrets[format('{0}_DOMAIN', matrix.instance)] }}" \
              -e AUTO_TLS=false \
              location-tracker:main
            
            echo "Waiting for container to start..."
            sleep 30
            
            if docker ps --format '{{.Names}}' | grep -q "^location-tracker-main$"; then
              echo "Container started successfully: location-tracker-main"
            else
              echo "ERROR: Container failed to start"
              docker logs location-tracker-main
              exit 1
            fi
            
            rm -f /tmp/location-tracker-main.tar

      - name: Health check
        if: steps.should_deploy.outputs.deploy == 'true'
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets[format('{0}_HOST', matrix.instance)] }}
          username: ${{ secrets[format('{0}_USER', matrix.instance)] }}
          key: ${{ secrets[format('{0}_SSH_KEY', matrix.instance)] }}
          script: |
            echo "=== Final Health Check ==="
            max_attempts=5
            attempt=1
            while [ $attempt -le $max_attempts ]; do
              echo "Health check attempt $attempt/$max_attempts..."
              if curl -f -s http://localhost:8080/api/health; then
                echo "Health check PASSED"
                echo "=== Main Branch Deployment Successful ==="
                if [ -f /etc/ssl/certs/location-tracker.crt ]; then
                  echo "Public URL: https://${{ secrets[format('{0}_DOMAIN', matrix.instance)] }}"
                else
                  echo "Public URL: http://${{ secrets[format('{0}_DOMAIN', matrix.instance)] }}"
                fi
                exit 0
              else
                echo "Health check failed (attempt $attempt/$max_attempts)"
                if [ $attempt -lt $max_attempts ]; then
                  sleep 10
                fi
              fi
              attempt=$((attempt + 1))
            done
            
            echo "ERROR: All health checks failed"
            docker logs --tail 50 location-tracker-main
            exit 1